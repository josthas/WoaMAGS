<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>AllegroGL: win.c Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript">
$(document).ready(initResizable);
</script>
<link href="alleggl.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<!-- Generated by Doxygen 1.7.3 -->
<div id="top">
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">AllegroGL&#160;<span id="projectnumber">0.4.4</span></div>
  </td>
 </tr>
 </tbody>
</table>
</div>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('win_8c.html','');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<h1>win.c</h1>  </div>
</div>
<div class="contents">
<div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/* This code is (C) AllegroGL contributors, and double licensed under</span>
<a name="l00002"></a>00002 <span class="comment"> * the GPL and zlib licenses. See gpl.txt or zlib.txt for details.</span>
<a name="l00003"></a>00003 <span class="comment"> */</span>
<a name="l00004"></a>00004 <span class="preprocessor">#include &lt;string.h&gt;</span>
<a name="l00005"></a>00005 <span class="preprocessor">#include &lt;allegro.h&gt;</span>
<a name="l00006"></a>00006 <span class="preprocessor">#include &lt;allegro/internal/aintern.h&gt;</span>
<a name="l00007"></a>00007 
<a name="l00008"></a>00008 
<a name="l00009"></a>00009 <span class="preprocessor">#include &quot;alleggl.h&quot;</span>
<a name="l00010"></a>00010 <span class="preprocessor">#include &quot;glvtable.h&quot;</span>
<a name="l00011"></a>00011 <span class="preprocessor">#include &quot;allglint.h&quot;</span>
<a name="l00012"></a>00012 
<a name="l00013"></a>00013 
<a name="l00014"></a>00014 <span class="keyword">static</span> BITMAP *allegro_gl_win_init_windowed(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> v_w, <span class="keywordtype">int</span> v_h,
<a name="l00015"></a>00015                                             <span class="keywordtype">int</span> color_depth);
<a name="l00016"></a>00016 <span class="keyword">static</span> BITMAP *allegro_gl_win_init_fullscreen(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> v_w, <span class="keywordtype">int</span> v_h,
<a name="l00017"></a>00017                                               <span class="keywordtype">int</span> color_depth);
<a name="l00018"></a>00018 <span class="keyword">static</span> <span class="keywordtype">void</span> allegro_gl_win_exit(<span class="keyword">struct</span> BITMAP *b);
<a name="l00019"></a>00019 <span class="keyword">static</span> GFX_MODE_LIST* allegro_gl_win_fetch_mode_list(<span class="keywordtype">void</span>);
<a name="l00020"></a>00020 
<a name="l00021"></a>00021 <span class="keyword">static</span> <span class="keyword">struct </span>allegro_gl_driver allegro_gl_win;
<a name="l00022"></a>00022 
<a name="l00023"></a>00023 <span class="preprocessor">#define PREFIX_I                &quot;agl-win INFO: &quot;</span>
<a name="l00024"></a>00024 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_W                &quot;agl-win WARNING: &quot;</span>
<a name="l00025"></a>00025 <span class="preprocessor"></span><span class="preprocessor">#define PREFIX_E                &quot;agl-win ERROR: &quot;</span>
<a name="l00026"></a>00026 <span class="preprocessor"></span>
<a name="l00027"></a>00027 
<a name="l00028"></a>00028 <span class="keyword">static</span> BITMAP *<a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a> = NULL;
<a name="l00029"></a>00029 
<a name="l00030"></a>00030 
<a name="l00031"></a>00031 <span class="comment">/* Windowed mode driver */</span>
<a name="l00032"></a>00032 GFX_DRIVER gfx_allegro_gl_windowed = {
<a name="l00033"></a>00033     <a class="code" href="alleggl_8h.html#a5fcf0497998fecc3c04bb5b6ce66782b" title="Windowed OpenGL graphics driver for Allegro.">GFX_OPENGL_WINDOWED</a>,
<a name="l00034"></a>00034     EMPTY_STRING,
<a name="l00035"></a>00035     EMPTY_STRING,
<a name="l00036"></a>00036     <span class="stringliteral">&quot;AllegroGL Windowed (Win32)&quot;</span>,
<a name="l00037"></a>00037     allegro_gl_win_init_windowed,
<a name="l00038"></a>00038     allegro_gl_win_exit,
<a name="l00039"></a>00039     NULL,                       <span class="comment">/* scrolling not implemented */</span>
<a name="l00040"></a>00040     NULL,                       <span class="comment">/* vsync, may use for flip? */</span>
<a name="l00041"></a>00041     NULL,                       <span class="comment">/* No h/w pallete, not using indexed mode */</span>
<a name="l00042"></a>00042     NULL, NULL,                 <span class="comment">/* Still no scrolling */</span>
<a name="l00043"></a>00043     NULL,                       <span class="comment">/* No triple buffering */</span>
<a name="l00044"></a>00044     <a class="code" href="videovtb_8c.html#a4dadb9b189453bc9693c032ce63fc5b4" title="create_video_bitmap() overload.">allegro_gl_create_video_bitmap</a>,
<a name="l00045"></a>00045     <a class="code" href="videovtb_8c.html#a69a97f6c3805246762fbefb545f20f87" title="destroy_video_bitmap() overload.">allegro_gl_destroy_video_bitmap</a>,
<a name="l00046"></a>00046     NULL, NULL,                 <span class="comment">/* No show/request video bitmaps */</span>
<a name="l00047"></a>00047     NULL, NULL,                 <span class="comment">/* No system bitmaps */</span>
<a name="l00048"></a>00048     allegro_gl_set_mouse_sprite,
<a name="l00049"></a>00049     allegro_gl_show_mouse,
<a name="l00050"></a>00050     allegro_gl_hide_mouse,
<a name="l00051"></a>00051     allegro_gl_move_mouse,
<a name="l00052"></a>00052     allegro_gl_drawing_mode,
<a name="l00053"></a>00053     NULL, NULL,           <span class="comment">/* No video state stuff */</span>
<a name="l00054"></a>00054     allegro_gl_set_blender_mode,
<a name="l00055"></a>00055     NULL,                       <span class="comment">/* No fetch_mode_list */</span>
<a name="l00056"></a>00056     0,0,                        <span class="comment">/* physical (not virtual!) screen size */</span>
<a name="l00057"></a>00057     0,                          <span class="comment">/* true if video memory is linear */</span>
<a name="l00058"></a>00058     0,                          <span class="comment">/* bank size, in bytes */</span>
<a name="l00059"></a>00059     0,                          <span class="comment">/* bank granularity, in bytes */</span>
<a name="l00060"></a>00060     0,                          <span class="comment">/* video memory size, in bytes */</span>
<a name="l00061"></a>00061     0,                          <span class="comment">/* physical address of video memory */</span>
<a name="l00062"></a>00062     TRUE                        <span class="comment">/* Windowed mode */</span>
<a name="l00063"></a>00063 };
<a name="l00064"></a>00064 
<a name="l00065"></a>00065 
<a name="l00066"></a>00066 <span class="comment">/* Fullscreen driver */</span>
<a name="l00067"></a>00067 GFX_DRIVER gfx_allegro_gl_fullscreen = {
<a name="l00068"></a>00068     <a class="code" href="alleggl_8h.html#afd00c615b3351d54382b5f883b99544f" title="Fullscreen OpenGL graphics driver for Allegro.">GFX_OPENGL_FULLSCREEN</a>,
<a name="l00069"></a>00069     EMPTY_STRING,
<a name="l00070"></a>00070     EMPTY_STRING,
<a name="l00071"></a>00071     <span class="stringliteral">&quot;AllegroGL Fullscreen (Win32)&quot;</span>,
<a name="l00072"></a>00072     allegro_gl_win_init_fullscreen,
<a name="l00073"></a>00073     allegro_gl_win_exit,
<a name="l00074"></a>00074     NULL,                       <span class="comment">/* scrolling not implemented */</span>
<a name="l00075"></a>00075     NULL,                       <span class="comment">/* vsync, may use for flip? */</span>
<a name="l00076"></a>00076     NULL,                       <span class="comment">/* No h/w pallete, not using indexed mode */</span>
<a name="l00077"></a>00077     NULL, NULL,                 <span class="comment">/* Still no scrolling */</span>
<a name="l00078"></a>00078     NULL,                       <span class="comment">/* No triple buffering */</span>
<a name="l00079"></a>00079     <a class="code" href="videovtb_8c.html#a4dadb9b189453bc9693c032ce63fc5b4" title="create_video_bitmap() overload.">allegro_gl_create_video_bitmap</a>,
<a name="l00080"></a>00080     <a class="code" href="videovtb_8c.html#a69a97f6c3805246762fbefb545f20f87" title="destroy_video_bitmap() overload.">allegro_gl_destroy_video_bitmap</a>,
<a name="l00081"></a>00081     NULL, NULL,                 <span class="comment">/* No show/request video bitmaps */</span>
<a name="l00082"></a>00082     NULL, NULL,                 <span class="comment">/* No system bitmaps */</span>
<a name="l00083"></a>00083     allegro_gl_set_mouse_sprite,
<a name="l00084"></a>00084     allegro_gl_show_mouse,
<a name="l00085"></a>00085     allegro_gl_hide_mouse,
<a name="l00086"></a>00086     allegro_gl_move_mouse,
<a name="l00087"></a>00087     allegro_gl_drawing_mode,
<a name="l00088"></a>00088     NULL, NULL,           <span class="comment">/* No video state stuff */</span>
<a name="l00089"></a>00089     allegro_gl_set_blender_mode,
<a name="l00090"></a>00090     allegro_gl_win_fetch_mode_list, <span class="comment">/* fetch_mode_list */</span>
<a name="l00091"></a>00091     0,0,                        <span class="comment">/* physical (not virtual!) screen size */</span>
<a name="l00092"></a>00092     0,                          <span class="comment">/* true if video memory is linear */</span>
<a name="l00093"></a>00093     0,                          <span class="comment">/* bank size, in bytes */</span>
<a name="l00094"></a>00094     0,                          <span class="comment">/* bank granularity, in bytes */</span>
<a name="l00095"></a>00095     0,                          <span class="comment">/* video memory size, in bytes */</span>
<a name="l00096"></a>00096     0,                          <span class="comment">/* physical address of video memory */</span>
<a name="l00097"></a>00097     FALSE                       <span class="comment">/* Windowed mode */</span>
<a name="l00098"></a>00098 };
<a name="l00099"></a>00099 
<a name="l00100"></a>00100 
<a name="l00101"></a>00101 <span class="comment">/* XXX &lt;rohannessian&gt; We should move those variable definitions into a struct,</span>
<a name="l00102"></a>00102 <span class="comment"> * for when multiple windows end up being supported.</span>
<a name="l00103"></a>00103 <span class="comment"> */</span>
<a name="l00104"></a>00104 
<a name="l00105"></a>00105 <span class="comment">/* Device Context used for the Allegro window. Note that only one window</span>
<a name="l00106"></a>00106 <span class="comment"> * is supported, so only onyl HDC is needed. This is shared by the AGL</span>
<a name="l00107"></a>00107 <span class="comment"> * extension code.</span>
<a name="l00108"></a>00108 <span class="comment"> */</span>
<a name="l00109"></a>00109 HDC __allegro_gl_hdc = NULL;
<a name="l00110"></a>00110 
<a name="l00111"></a>00111 <span class="comment">/* Render Context used by AllegroGL, once screen mode was set. Note that only</span>
<a name="l00112"></a>00112 <span class="comment"> * a single window is supported.</span>
<a name="l00113"></a>00113 <span class="comment"> */</span>
<a name="l00114"></a>00114 <span class="keyword">static</span> HGLRC allegro_glrc = NULL;
<a name="l00115"></a>00115 
<a name="l00116"></a>00116 <span class="comment">/* Full-screen flag, for the current context. */</span>
<a name="l00117"></a>00117 <span class="keyword">static</span> <span class="keywordtype">int</span> fullscreen = 0;
<a name="l00118"></a>00118 
<a name="l00119"></a>00119 <span class="comment">/* Current window handle */</span>
<a name="l00120"></a>00120 <span class="keyword">static</span> HWND wnd = NULL;
<a name="l00121"></a>00121 
<a name="l00122"></a>00122 <span class="comment">/* If AGL was initialized */</span>
<a name="l00123"></a>00123 <span class="keyword">static</span> <span class="keywordtype">int</span> initialized = 0;
<a name="l00124"></a>00124 
<a name="l00125"></a>00125 <span class="comment">/* XXX &lt;rohannessian&gt; Put those globals as function parameters */</span>
<a name="l00126"></a>00126 <span class="comment">/* Note - these globals should really end up as parameters to functions.</span>
<a name="l00127"></a>00127 <span class="comment"> */</span>
<a name="l00128"></a>00128 <span class="keyword">static</span> DWORD style_saved, exstyle_saved;
<a name="l00129"></a>00129 <span class="keyword">static</span> DEVMODE dm_saved;
<a name="l00130"></a>00130 <span class="keyword">static</span> <span class="keywordtype">int</span> test_windows_created = 0;
<a name="l00131"></a>00131 <span class="keyword">static</span> <span class="keywordtype">int</span> new_w = 0, new_h = 0;
<a name="l00132"></a>00132 
<a name="l00133"></a>00133 <span class="keyword">static</span> PIXELFORMATDESCRIPTOR pfd = {
<a name="l00134"></a>00134     <span class="keyword">sizeof</span>(PIXELFORMATDESCRIPTOR),  <span class="comment">/* size of this pfd */</span>
<a name="l00135"></a>00135     1,                          <span class="comment">/* version number */</span>
<a name="l00136"></a>00136     PFD_DRAW_TO_WINDOW          <span class="comment">/* support window */</span>
<a name="l00137"></a>00137         | PFD_SUPPORT_OPENGL    <span class="comment">/* support OpenGL */</span>
<a name="l00138"></a>00138         | PFD_DOUBLEBUFFER,     <span class="comment">/* double buffered */</span>
<a name="l00139"></a>00139     PFD_TYPE_RGBA,              <span class="comment">/* RGBA type */</span>
<a name="l00140"></a>00140     24,                         <span class="comment">/* 24-bit color depth */</span>
<a name="l00141"></a>00141     0, 0, 0, 0, 0, 0,           <span class="comment">/* color bits ignored */</span>
<a name="l00142"></a>00142     0,                          <span class="comment">/* no alpha buffer */</span>
<a name="l00143"></a>00143     0,                          <span class="comment">/* shift bit ignored */</span>
<a name="l00144"></a>00144     0,                          <span class="comment">/* no accumulation buffer */</span>
<a name="l00145"></a>00145     0, 0, 0, 0,                 <span class="comment">/* accum bits ignored */</span>
<a name="l00146"></a>00146     0,                          <span class="comment">/* z-buffer */</span>
<a name="l00147"></a>00147     0,                          <span class="comment">/* no stencil buffer */</span>
<a name="l00148"></a>00148     0,                          <span class="comment">/* no auxiliary buffer */</span>
<a name="l00149"></a>00149     PFD_MAIN_PLANE,             <span class="comment">/* main layer */</span>
<a name="l00150"></a>00150     0,                          <span class="comment">/* reserved */</span>
<a name="l00151"></a>00151     0, 0, 0                     <span class="comment">/* layer masks ignored */</span>
<a name="l00152"></a>00152 };
<a name="l00153"></a>00153 
<a name="l00154"></a>00154 
<a name="l00155"></a>00155 
<a name="l00156"></a>00156 <span class="comment">/* Logs a Win32 error/warning message in the log file.</span>
<a name="l00157"></a>00157 <span class="comment"> */</span>
<a name="l00158"></a>00158 <span class="keyword">static</span> <span class="keywordtype">void</span> log_win32_msg(<span class="keyword">const</span> <span class="keywordtype">char</span> *prefix, <span class="keyword">const</span> <span class="keywordtype">char</span> *func,
<a name="l00159"></a>00159                           <span class="keyword">const</span> <span class="keywordtype">char</span> *error_msg, DWORD err) {
<a name="l00160"></a>00160 
<a name="l00161"></a>00161     <span class="keywordtype">char</span> *err_msg = NULL;
<a name="l00162"></a>00162     BOOL free_msg = TRUE;
<a name="l00163"></a>00163 
<a name="l00164"></a>00164     <span class="comment">/* Get the formatting error string from Windows. Note that only the</span>
<a name="l00165"></a>00165 <span class="comment">     * bottom 14 bits matter - the rest are reserved for various library</span>
<a name="l00166"></a>00166 <span class="comment">     * IDs and type of error.</span>
<a name="l00167"></a>00167 <span class="comment">     */</span>
<a name="l00168"></a>00168     <span class="keywordflow">if</span> (!FormatMessage(FORMAT_MESSAGE_ALLOCATE_BUFFER
<a name="l00169"></a>00169                      | FORMAT_MESSAGE_FROM_SYSTEM
<a name="l00170"></a>00170                      | FORMAT_MESSAGE_IGNORE_INSERTS,
<a name="l00171"></a>00171                      NULL, err &amp; 0x3FFF,
<a name="l00172"></a>00172                      MAKELANGID(LANG_NEUTRAL, SUBLANG_DEFAULT),
<a name="l00173"></a>00173                      (LPTSTR) &amp;err_msg, 0, NULL)) {
<a name="l00174"></a>00174         err_msg = <span class="stringliteral">&quot;(Unable to decode error code)  &quot;</span>;
<a name="l00175"></a>00175         free_msg = FALSE;
<a name="l00176"></a>00176     }
<a name="l00177"></a>00177 
<a name="l00178"></a>00178     <span class="comment">/* Remove two trailing characters */</span>
<a name="l00179"></a>00179     <span class="keywordflow">if</span> (err_msg &amp;&amp; strlen(err_msg) &gt; 1)
<a name="l00180"></a>00180         *(err_msg + strlen(err_msg) - 2) = <span class="charliteral">&#39;\0&#39;</span>;
<a name="l00181"></a>00181 
<a name="l00182"></a>00182     TRACE(<span class="stringliteral">&quot;%s%s(): %s %s (0x%08lx)\n&quot;</span>, prefix, func,
<a name="l00183"></a>00183           error_msg ? error_msg : <span class="stringliteral">&quot;&quot;</span>,
<a name="l00184"></a>00184           err_msg ? err_msg : <span class="stringliteral">&quot;(null)&quot;</span>,
<a name="l00185"></a>00185           (<span class="keywordtype">unsigned</span> <span class="keywordtype">long</span>)err);
<a name="l00186"></a>00186 
<a name="l00187"></a>00187     <span class="keywordflow">if</span> (free_msg) {
<a name="l00188"></a>00188         LocalFree(err_msg);
<a name="l00189"></a>00189     }
<a name="l00190"></a>00190 
<a name="l00191"></a>00191     <span class="keywordflow">return</span>;
<a name="l00192"></a>00192 }
<a name="l00193"></a>00193 
<a name="l00194"></a>00194 
<a name="l00195"></a>00195 
<a name="l00196"></a>00196 <span class="comment">/* Logs an error */</span>
<a name="l00197"></a>00197 <span class="keyword">static</span> <span class="keywordtype">void</span> log_win32_error(<span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span> *error_msg,
<a name="l00198"></a>00198                             DWORD err) {
<a name="l00199"></a>00199     log_win32_msg(PREFIX_E, func, error_msg, err);
<a name="l00200"></a>00200 }
<a name="l00201"></a>00201 
<a name="l00202"></a>00202 
<a name="l00203"></a>00203 
<a name="l00204"></a>00204 <span class="comment">/* Logs a warning */</span>
<a name="l00205"></a>00205 <span class="keyword">static</span> <span class="keywordtype">void</span> log_win32_warning(<span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span> *error_msg,
<a name="l00206"></a>00206                               DWORD err) {
<a name="l00207"></a>00207     log_win32_msg(PREFIX_W, func, error_msg, err);
<a name="l00208"></a>00208 }
<a name="l00209"></a>00209 
<a name="l00210"></a>00210 
<a name="l00211"></a>00211 
<a name="l00212"></a>00212 <span class="comment">/* Logs a note */</span>
<a name="l00213"></a>00213 <span class="keyword">static</span> <span class="keywordtype">void</span> log_win32_note(<span class="keyword">const</span> <span class="keywordtype">char</span> *func, <span class="keyword">const</span> <span class="keywordtype">char</span> *error_msg, DWORD err) {
<a name="l00214"></a>00214     log_win32_msg(PREFIX_I, func, error_msg, err);
<a name="l00215"></a>00215 }
<a name="l00216"></a>00216 
<a name="l00217"></a>00217 
<a name="l00218"></a>00218 
<a name="l00219"></a>00219 <span class="comment">/* Define the AllegroGL Test window class */</span>
<a name="l00220"></a>00220 <span class="preprocessor">#define ALLEGROGL_TEST_WINDOW_CLASS &quot;AllegroGLTestWindow&quot;</span>
<a name="l00221"></a>00221 <span class="preprocessor"></span>
<a name="l00222"></a>00222 
<a name="l00223"></a>00223 <span class="comment">/* Registers the test window</span>
<a name="l00224"></a>00224 <span class="comment"> * Returns 0 on success, non-zero on failure.</span>
<a name="l00225"></a>00225 <span class="comment"> */</span>
<a name="l00226"></a>00226 <span class="keyword">static</span> <span class="keywordtype">int</span> register_test_window()
<a name="l00227"></a>00227 {
<a name="l00228"></a>00228     WNDCLASS wc;
<a name="l00229"></a>00229 
<a name="l00230"></a>00230     memset(&amp;wc, 0, <span class="keyword">sizeof</span>(wc));
<a name="l00231"></a>00231     wc.style = CS_HREDRAW | CS_VREDRAW | CS_OWNDC;
<a name="l00232"></a>00232     wc.lpfnWndProc = DefWindowProc;
<a name="l00233"></a>00233     wc.hInstance = GetModuleHandle(NULL);
<a name="l00234"></a>00234     wc.hIcon = LoadIcon(GetModuleHandle(NULL), IDI_APPLICATION);
<a name="l00235"></a>00235     wc.hCursor = LoadCursor(NULL, IDC_ARROW);
<a name="l00236"></a>00236     wc.lpszClassName = ALLEGROGL_TEST_WINDOW_CLASS;
<a name="l00237"></a>00237 
<a name="l00238"></a>00238     <span class="keywordflow">if</span> (!RegisterClass(&amp;wc)) {
<a name="l00239"></a>00239         DWORD err = GetLastError();
<a name="l00240"></a>00240 
<a name="l00241"></a>00241         <span class="keywordflow">if</span> (err != ERROR_CLASS_ALREADY_EXISTS) {
<a name="l00242"></a>00242             log_win32_error(<span class="stringliteral">&quot;register_test_window&quot;</span>,
<a name="l00243"></a>00243                             <span class="stringliteral">&quot;Unable to register the window class!&quot;</span>, err);
<a name="l00244"></a>00244             <span class="keywordflow">return</span> -1;
<a name="l00245"></a>00245         }
<a name="l00246"></a>00246     }
<a name="l00247"></a>00247 
<a name="l00248"></a>00248     <span class="keywordflow">return</span> 0;
<a name="l00249"></a>00249 }
<a name="l00250"></a>00250 
<a name="l00251"></a>00251 
<a name="l00252"></a>00252 
<a name="l00253"></a>00253 
<a name="l00254"></a>00254 <span class="comment">/* Creates the test window.</span>
<a name="l00255"></a>00255 <span class="comment"> * The window class must have already been registered.</span>
<a name="l00256"></a>00256 <span class="comment"> * Returns the window handle, or NULL on failure.</span>
<a name="l00257"></a>00257 <span class="comment"> */</span>
<a name="l00258"></a>00258 <span class="keyword">static</span> HWND create_test_window()
<a name="l00259"></a>00259 {
<a name="l00260"></a>00260     HWND wnd = CreateWindow(ALLEGROGL_TEST_WINDOW_CLASS,
<a name="l00261"></a>00261                             <span class="stringliteral">&quot;AllegroGL Test Window&quot;</span>,
<a name="l00262"></a>00262                             WS_POPUP | WS_CLIPCHILDREN,
<a name="l00263"></a>00263                             0, 0, new_w, new_h,
<a name="l00264"></a>00264                             NULL, NULL,
<a name="l00265"></a>00265                             GetModuleHandle(NULL),
<a name="l00266"></a>00266                             NULL);
<a name="l00267"></a>00267 
<a name="l00268"></a>00268     <span class="keywordflow">if</span> (!wnd) {
<a name="l00269"></a>00269         log_win32_error(<span class="stringliteral">&quot;create_test_window&quot;</span>,
<a name="l00270"></a>00270                         <span class="stringliteral">&quot;Unable to create a test window!&quot;</span>, GetLastError());
<a name="l00271"></a>00271         <span class="keywordflow">return</span> NULL;
<a name="l00272"></a>00272     }       
<a name="l00273"></a>00273 
<a name="l00274"></a>00274     test_windows_created++;
<a name="l00275"></a>00275     <span class="keywordflow">return</span> wnd;
<a name="l00276"></a>00276 }
<a name="l00277"></a>00277 
<a name="l00278"></a>00278 
<a name="l00279"></a>00279 
<a name="l00280"></a>00280 <span class="comment">/* Print the pixel format info */</span>
<a name="l00281"></a>00281 <span class="keyword">static</span> <span class="keywordtype">void</span> print_pixel_format(<span class="keyword">struct</span> allegro_gl_display_info *dinfo) {
<a name="l00282"></a>00282 
<a name="l00283"></a>00283     <span class="keywordflow">if</span> (!dinfo) {
<a name="l00284"></a>00284         <span class="keywordflow">return</span>;
<a name="l00285"></a>00285     }
<a name="l00286"></a>00286     
<a name="l00287"></a>00287     TRACE(PREFIX_I <span class="stringliteral">&quot;Acceleration: %s\n&quot;</span>, ((dinfo-&gt;rmethod == 0) ? <span class="stringliteral">&quot;No&quot;</span>
<a name="l00288"></a>00288                              : ((dinfo-&gt;rmethod == 1) ? <span class="stringliteral">&quot;Yes&quot;</span> : <span class="stringliteral">&quot;Unknown&quot;</span>)));
<a name="l00289"></a>00289     TRACE(PREFIX_I <span class="stringliteral">&quot;RGBA: %i.%i.%i.%i\n&quot;</span>, dinfo-&gt;pixel_size.rgba.r,
<a name="l00290"></a>00290           dinfo-&gt;pixel_size.rgba.g, dinfo-&gt;pixel_size.rgba.b,
<a name="l00291"></a>00291           dinfo-&gt;pixel_size.rgba.a);
<a name="l00292"></a>00292     
<a name="l00293"></a>00293     TRACE(PREFIX_I <span class="stringliteral">&quot;Accum: %i.%i.%i.%i\n&quot;</span>, dinfo-&gt;accum_size.rgba.r,
<a name="l00294"></a>00294           dinfo-&gt;accum_size.rgba.g, dinfo-&gt;accum_size.rgba.b,
<a name="l00295"></a>00295           dinfo-&gt;accum_size.rgba.a);
<a name="l00296"></a>00296     
<a name="l00297"></a>00297     TRACE(PREFIX_I <span class="stringliteral">&quot;DblBuf: %i Zbuf: %i Stereo: %i Aux: %i Stencil: %i\n&quot;</span>,
<a name="l00298"></a>00298           dinfo-&gt;doublebuffered, dinfo-&gt;depth_size, dinfo-&gt;stereo,
<a name="l00299"></a>00299           dinfo-&gt;aux_buffers, dinfo-&gt;stencil_size);
<a name="l00300"></a>00300     
<a name="l00301"></a>00301     TRACE(PREFIX_I <span class="stringliteral">&quot;Shift: %i.%i.%i.%i\n&quot;</span>, dinfo-&gt;r_shift, dinfo-&gt;g_shift,
<a name="l00302"></a>00302           dinfo-&gt;b_shift, dinfo-&gt;a_shift);
<a name="l00303"></a>00303 
<a name="l00304"></a>00304     TRACE(PREFIX_I <span class="stringliteral">&quot;Sample Buffers: %i Samples: %i\n&quot;</span>,
<a name="l00305"></a>00305           dinfo-&gt;sample_buffers, dinfo-&gt;samples);
<a name="l00306"></a>00306     
<a name="l00307"></a>00307     TRACE(PREFIX_I <span class="stringliteral">&quot;Decoded bpp: %i\n&quot;</span>, dinfo-&gt;colour_depth);   
<a name="l00308"></a>00308 }
<a name="l00309"></a>00309 
<a name="l00310"></a>00310 
<a name="l00311"></a>00311 
<a name="l00312"></a>00312 <span class="comment">/* Decodes the pixel format into an agl_display_info struct and logs the pixel</span>
<a name="l00313"></a>00313 <span class="comment"> * format in the trace file.</span>
<a name="l00314"></a>00314 <span class="comment"> */</span>
<a name="l00315"></a>00315 <span class="keyword">static</span> <span class="keywordtype">int</span> decode_pixel_format(PIXELFORMATDESCRIPTOR * pfd, HDC hdc, <span class="keywordtype">int</span> format,
<a name="l00316"></a>00316                                <span class="keyword">struct</span> allegro_gl_display_info *dinfo,
<a name="l00317"></a>00317                                <span class="keywordtype">int</span> desktop_depth)
<a name="l00318"></a>00318 {
<a name="l00319"></a>00319     TRACE(PREFIX_I <span class="stringliteral">&quot;Decoding: \n&quot;</span>);
<a name="l00320"></a>00320     <span class="comment">/* Not interested if it doesn&#39;t support OpenGL and RGBA */</span>
<a name="l00321"></a>00321     <span class="keywordflow">if</span> (!(pfd-&gt;dwFlags &amp; PFD_SUPPORT_OPENGL)) {
<a name="l00322"></a>00322         TRACE(PREFIX_I <span class="stringliteral">&quot;OpenGL Unsupported\n&quot;</span>);
<a name="l00323"></a>00323         <span class="keywordflow">return</span> -1;
<a name="l00324"></a>00324     }
<a name="l00325"></a>00325     <span class="keywordflow">if</span> (pfd-&gt;iPixelType != PFD_TYPE_RGBA) {
<a name="l00326"></a>00326         TRACE(PREFIX_I <span class="stringliteral">&quot;Not RGBA mode\n&quot;</span>);
<a name="l00327"></a>00327         <span class="keywordflow">return</span> -1;
<a name="l00328"></a>00328     }
<a name="l00329"></a>00329 
<a name="l00330"></a>00330     <span class="keywordflow">if</span> ((pfd-&gt;cColorBits != desktop_depth)
<a name="l00331"></a>00331      &amp;&amp; (pfd-&gt;cColorBits != 32 || desktop_depth &lt; 24)) {
<a name="l00332"></a>00332         TRACE(PREFIX_I <span class="stringliteral">&quot;Current color depth != &quot;</span>
<a name="l00333"></a>00333               <span class="stringliteral">&quot;pixel format color depth\n&quot;</span>);
<a name="l00334"></a>00334         <span class="comment">//return -1;  /* XXX &lt;rohannessian&gt; Why is this a bad thing? */</span>
<a name="l00335"></a>00335     }
<a name="l00336"></a>00336     
<a name="l00337"></a>00337 
<a name="l00338"></a>00338     <span class="comment">/* hardware acceleration */</span>
<a name="l00339"></a>00339     <span class="keywordflow">if</span> (((pfd-&gt;dwFlags &amp; PFD_GENERIC_ACCELERATED)
<a name="l00340"></a>00340          &amp;&amp; (pfd-&gt;dwFlags &amp; PFD_GENERIC_FORMAT))
<a name="l00341"></a>00341         || (!(pfd-&gt;dwFlags &amp; PFD_GENERIC_ACCELERATED)
<a name="l00342"></a>00342             &amp;&amp; !(pfd-&gt;dwFlags &amp; PFD_GENERIC_FORMAT)))
<a name="l00343"></a>00343         dinfo-&gt;rmethod = 1;
<a name="l00344"></a>00344     <span class="keywordflow">else</span>
<a name="l00345"></a>00345         dinfo-&gt;rmethod = 0;
<a name="l00346"></a>00346 
<a name="l00347"></a>00347 
<a name="l00348"></a>00348     <span class="comment">/* Depths of colour buffers */</span>
<a name="l00349"></a>00349     dinfo-&gt;pixel_size.rgba.r = pfd-&gt;cRedBits;
<a name="l00350"></a>00350     dinfo-&gt;pixel_size.rgba.g = pfd-&gt;cGreenBits;
<a name="l00351"></a>00351     dinfo-&gt;pixel_size.rgba.b = pfd-&gt;cBlueBits;
<a name="l00352"></a>00352     dinfo-&gt;pixel_size.rgba.a = pfd-&gt;cAlphaBits;
<a name="l00353"></a>00353 
<a name="l00354"></a>00354     <span class="comment">/* Depths of accumulation buffer */</span>
<a name="l00355"></a>00355     dinfo-&gt;accum_size.rgba.r = pfd-&gt;cAccumRedBits;
<a name="l00356"></a>00356     dinfo-&gt;accum_size.rgba.g = pfd-&gt;cAccumGreenBits;
<a name="l00357"></a>00357     dinfo-&gt;accum_size.rgba.b = pfd-&gt;cAccumBlueBits;
<a name="l00358"></a>00358     dinfo-&gt;accum_size.rgba.a = pfd-&gt;cAccumAlphaBits;
<a name="l00359"></a>00359 
<a name="l00360"></a>00360     <span class="comment">/* Miscellaneous settings */</span>
<a name="l00361"></a>00361     dinfo-&gt;doublebuffered = pfd-&gt;dwFlags &amp; PFD_DOUBLEBUFFER;
<a name="l00362"></a>00362     dinfo-&gt;stereo = pfd-&gt;dwFlags &amp; PFD_STEREO;
<a name="l00363"></a>00363     dinfo-&gt;aux_buffers = pfd-&gt;cAuxBuffers;
<a name="l00364"></a>00364     dinfo-&gt;depth_size = pfd-&gt;cDepthBits;
<a name="l00365"></a>00365     dinfo-&gt;stencil_size = pfd-&gt;cStencilBits;
<a name="l00366"></a>00366 
<a name="l00367"></a>00367     <span class="comment">/* These are the component shifts, like Allegro&#39;s _rgb_*_shift_*. */</span>
<a name="l00368"></a>00368     dinfo-&gt;r_shift = pfd-&gt;cRedShift;
<a name="l00369"></a>00369     dinfo-&gt;g_shift = pfd-&gt;cGreenShift;
<a name="l00370"></a>00370     dinfo-&gt;b_shift = pfd-&gt;cBlueShift;
<a name="l00371"></a>00371     dinfo-&gt;a_shift = pfd-&gt;cAlphaShift;
<a name="l00372"></a>00372 
<a name="l00373"></a>00373     <span class="comment">/* Multisampling isn&#39;t supported under Windows if we don&#39;t also use</span>
<a name="l00374"></a>00374 <span class="comment">     * WGL_ARB_pixel_format or WGL_EXT_pixel_format.</span>
<a name="l00375"></a>00375 <span class="comment">     */</span>
<a name="l00376"></a>00376     dinfo-&gt;sample_buffers = 0;
<a name="l00377"></a>00377     dinfo-&gt;samples = 0;
<a name="l00378"></a>00378 
<a name="l00379"></a>00379     <span class="comment">/* Float depth/color isn&#39;t supported under Windows if we don&#39;t also use</span>
<a name="l00380"></a>00380 <span class="comment">     * AGL_ARB_pixel_format or WGL_EXT_pixel_format.</span>
<a name="l00381"></a>00381 <span class="comment">     */</span>
<a name="l00382"></a>00382     dinfo-&gt;float_color = 0;
<a name="l00383"></a>00383     dinfo-&gt;float_depth = 0;
<a name="l00384"></a>00384 
<a name="l00385"></a>00385     <span class="comment">/* This bit is the same as the X code, setting some things based on</span>
<a name="l00386"></a>00386 <span class="comment">     * what we&#39;ve read out of the PFD. */</span>
<a name="l00387"></a>00387     dinfo-&gt;colour_depth = 0;
<a name="l00388"></a>00388     <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.r == 5 &amp;&amp; dinfo-&gt;pixel_size.rgba.b == 5) {
<a name="l00389"></a>00389         <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.g == 5)
<a name="l00390"></a>00390             dinfo-&gt;colour_depth = 15;
<a name="l00391"></a>00391         <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.g == 6)
<a name="l00392"></a>00392             dinfo-&gt;colour_depth = 16;
<a name="l00393"></a>00393     }
<a name="l00394"></a>00394     <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.r == 8
<a name="l00395"></a>00395         &amp;&amp; dinfo-&gt;pixel_size.rgba.g == 8 &amp;&amp; dinfo-&gt;pixel_size.rgba.b == 8) {
<a name="l00396"></a>00396         <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.a == 8)
<a name="l00397"></a>00397             dinfo-&gt;colour_depth = 32;
<a name="l00398"></a>00398         <span class="keywordflow">else</span>
<a name="l00399"></a>00399             dinfo-&gt;colour_depth = 24;
<a name="l00400"></a>00400     }
<a name="l00401"></a>00401 
<a name="l00402"></a>00402 
<a name="l00403"></a>00403     dinfo-&gt;allegro_format = (dinfo-&gt;colour_depth != 0)
<a name="l00404"></a>00404         &amp;&amp; (dinfo-&gt;g_shift == dinfo-&gt;pixel_size.rgba.b)
<a name="l00405"></a>00405         &amp;&amp; (dinfo-&gt;r_shift * dinfo-&gt;b_shift == 0)
<a name="l00406"></a>00406         &amp;&amp; (dinfo-&gt;r_shift + dinfo-&gt;b_shift ==
<a name="l00407"></a>00407             dinfo-&gt;pixel_size.rgba.b + dinfo-&gt;pixel_size.rgba.g);
<a name="l00408"></a>00408 
<a name="l00409"></a>00409     <span class="keywordflow">return</span> 0;
<a name="l00410"></a>00410 }
<a name="l00411"></a>00411 
<a name="l00412"></a>00412 
<a name="l00413"></a>00413 
<a name="l00414"></a>00414 <span class="comment">/* Decodes the pixel format into an agl_display_info struct and logs the pixel</span>
<a name="l00415"></a>00415 <span class="comment"> * format in the trace file.</span>
<a name="l00416"></a>00416 <span class="comment"> */</span>
<a name="l00417"></a>00417 <span class="keyword">static</span> <span class="keywordtype">int</span> decode_pixel_format_attrib(<span class="keyword">struct</span> allegro_gl_display_info *dinfo,
<a name="l00418"></a>00418                           <span class="keywordtype">int</span> num_attribs, <span class="keyword">const</span> <span class="keywordtype">int</span> *attrib, <span class="keyword">const</span> <span class="keywordtype">int</span> *value,
<a name="l00419"></a>00419                           <span class="keywordtype">int</span> desktop_depth) {
<a name="l00420"></a>00420     <span class="keywordtype">int</span> i;
<a name="l00421"></a>00421     
<a name="l00422"></a>00422     TRACE(PREFIX_I <span class="stringliteral">&quot;Decoding: \n&quot;</span>);
<a name="l00423"></a>00423 
<a name="l00424"></a>00424     dinfo-&gt;samples = 0;
<a name="l00425"></a>00425     dinfo-&gt;sample_buffers = 0;
<a name="l00426"></a>00426     dinfo-&gt;float_depth = 0;
<a name="l00427"></a>00427     dinfo-&gt;float_color = 0;
<a name="l00428"></a>00428 
<a name="l00429"></a>00429     <span class="keywordflow">for</span> (i = 0; i &lt; num_attribs; i++) {
<a name="l00430"></a>00430 
<a name="l00431"></a>00431         <span class="comment">/* Not interested if it doesn&#39;t support OpenGL or window drawing or</span>
<a name="l00432"></a>00432 <span class="comment">         * RGBA.</span>
<a name="l00433"></a>00433 <span class="comment">         */</span>
<a name="l00434"></a>00434         <span class="keywordflow">if</span> (attrib[i] == WGL_SUPPORT_OPENGL_ARB &amp;&amp; value[i] == 0) { 
<a name="l00435"></a>00435             TRACE(PREFIX_I <span class="stringliteral">&quot;OpenGL Unsupported\n&quot;</span>);
<a name="l00436"></a>00436             <span class="keywordflow">return</span> -1;
<a name="l00437"></a>00437         }
<a name="l00438"></a>00438         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_DRAW_TO_WINDOW_ARB &amp;&amp; value[i] == 0) {    
<a name="l00439"></a>00439             TRACE(PREFIX_I <span class="stringliteral">&quot;Can&#39;t draw to window\n&quot;</span>);
<a name="l00440"></a>00440             <span class="keywordflow">return</span> -1;
<a name="l00441"></a>00441         }
<a name="l00442"></a>00442         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_PIXEL_TYPE_ARB &amp;&amp;
<a name="l00443"></a>00443                 (value[i] != WGL_TYPE_RGBA_ARB
<a name="l00444"></a>00444                  &amp;&amp; value[i] != WGL_TYPE_RGBA_FLOAT_ARB)) { 
<a name="l00445"></a>00445             TRACE(PREFIX_I <span class="stringliteral">&quot;Not RGBA mode\n&quot;</span>);
<a name="l00446"></a>00446             <span class="keywordflow">return</span> -1;
<a name="l00447"></a>00447         }
<a name="l00448"></a>00448         <span class="comment">/* Check for color depth matching */</span>
<a name="l00449"></a>00449         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_COLOR_BITS_ARB) {
<a name="l00450"></a>00450             <span class="keywordflow">if</span> ((value[i] != desktop_depth)
<a name="l00451"></a>00451              &amp;&amp; (value[i] != 32 || desktop_depth &lt; 24)) {
<a name="l00452"></a>00452                 TRACE(PREFIX_I <span class="stringliteral">&quot;Current color depth != &quot;</span>
<a name="l00453"></a>00453                       <span class="stringliteral">&quot;pixel format color depth\n&quot;</span>);
<a name="l00454"></a>00454                 <span class="comment">//return -1; /* XXX &lt;rohannessian&gt; Why is this a bad thing? */</span>
<a name="l00455"></a>00455             }
<a name="l00456"></a>00456         }
<a name="l00457"></a>00457         <span class="comment">/* hardware acceleration */</span>
<a name="l00458"></a>00458         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_ACCELERATION_ARB) {
<a name="l00459"></a>00459             dinfo-&gt;rmethod = (value[i] == WGL_NO_ACCELERATION_ARB) ? 0 : 1;
<a name="l00460"></a>00460         }
<a name="l00461"></a>00461         <span class="comment">/* Depths of colour buffers */</span>
<a name="l00462"></a>00462         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_RED_BITS_ARB) {
<a name="l00463"></a>00463             dinfo-&gt;pixel_size.rgba.r = value[i];
<a name="l00464"></a>00464         }
<a name="l00465"></a>00465         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_GREEN_BITS_ARB) {
<a name="l00466"></a>00466             dinfo-&gt;pixel_size.rgba.g = value[i];
<a name="l00467"></a>00467         }
<a name="l00468"></a>00468         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_BLUE_BITS_ARB) {
<a name="l00469"></a>00469             dinfo-&gt;pixel_size.rgba.b = value[i];
<a name="l00470"></a>00470         }
<a name="l00471"></a>00471         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_ALPHA_BITS_ARB) {
<a name="l00472"></a>00472             dinfo-&gt;pixel_size.rgba.a = value[i];
<a name="l00473"></a>00473         }
<a name="l00474"></a>00474         <span class="comment">/* Shift of color components */</span>
<a name="l00475"></a>00475         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_RED_SHIFT_ARB) {
<a name="l00476"></a>00476             dinfo-&gt;r_shift = value[i];
<a name="l00477"></a>00477         }
<a name="l00478"></a>00478         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_GREEN_SHIFT_ARB) {
<a name="l00479"></a>00479             dinfo-&gt;g_shift = value[i];
<a name="l00480"></a>00480         }
<a name="l00481"></a>00481         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_BLUE_SHIFT_ARB) {
<a name="l00482"></a>00482             dinfo-&gt;b_shift = value[i];
<a name="l00483"></a>00483         }
<a name="l00484"></a>00484         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_ALPHA_SHIFT_ARB) {
<a name="l00485"></a>00485             dinfo-&gt;a_shift = value[i];
<a name="l00486"></a>00486         }
<a name="l00487"></a>00487 
<a name="l00488"></a>00488         <span class="comment">/* Depths of accumulation buffer */</span>
<a name="l00489"></a>00489         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_ACCUM_RED_BITS_ARB) {
<a name="l00490"></a>00490             dinfo-&gt;accum_size.rgba.r = value[i];
<a name="l00491"></a>00491         }
<a name="l00492"></a>00492         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_ACCUM_GREEN_BITS_ARB) {
<a name="l00493"></a>00493             dinfo-&gt;accum_size.rgba.g = value[i];
<a name="l00494"></a>00494         }
<a name="l00495"></a>00495         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_ACCUM_BLUE_BITS_ARB) {
<a name="l00496"></a>00496             dinfo-&gt;accum_size.rgba.b = value[i];
<a name="l00497"></a>00497         }
<a name="l00498"></a>00498         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_ACCUM_ALPHA_BITS_ARB) {
<a name="l00499"></a>00499             dinfo-&gt;accum_size.rgba.a = value[i];
<a name="l00500"></a>00500         }   
<a name="l00501"></a>00501         <span class="comment">/* Miscellaneous settings */</span>
<a name="l00502"></a>00502         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_DOUBLE_BUFFER_ARB) {
<a name="l00503"></a>00503             dinfo-&gt;doublebuffered = value[i];
<a name="l00504"></a>00504         }
<a name="l00505"></a>00505         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_STEREO_ARB) {
<a name="l00506"></a>00506             dinfo-&gt;stereo = value[i];
<a name="l00507"></a>00507         }
<a name="l00508"></a>00508         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_AUX_BUFFERS_ARB) {
<a name="l00509"></a>00509             dinfo-&gt;aux_buffers = value[i];
<a name="l00510"></a>00510         }
<a name="l00511"></a>00511         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_DEPTH_BITS_ARB) {
<a name="l00512"></a>00512             dinfo-&gt;depth_size = value[i];
<a name="l00513"></a>00513         }
<a name="l00514"></a>00514         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_STENCIL_BITS_ARB) {
<a name="l00515"></a>00515             dinfo-&gt;stencil_size = value[i];
<a name="l00516"></a>00516         }
<a name="l00517"></a>00517         <span class="comment">/* Multisampling bits */</span>
<a name="l00518"></a>00518         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_SAMPLE_BUFFERS_ARB) {
<a name="l00519"></a>00519             dinfo-&gt;sample_buffers = value[i];
<a name="l00520"></a>00520         }
<a name="l00521"></a>00521         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_SAMPLES_ARB) {
<a name="l00522"></a>00522             dinfo-&gt;samples = value[i];
<a name="l00523"></a>00523         }
<a name="l00524"></a>00524         <span class="comment">/* Float color */</span>
<a name="l00525"></a>00525         <span class="keywordflow">if</span> (attrib[i] == WGL_PIXEL_TYPE_ARB
<a name="l00526"></a>00526           &amp;&amp; value[i] == WGL_TYPE_RGBA_FLOAT_ARB) {
<a name="l00527"></a>00527             dinfo-&gt;float_color = TRUE;
<a name="l00528"></a>00528         }
<a name="l00529"></a>00529         <span class="comment">/* Float depth */</span>
<a name="l00530"></a>00530         <span class="keywordflow">else</span> <span class="keywordflow">if</span> (attrib[i] == WGL_DEPTH_FLOAT_EXT) {
<a name="l00531"></a>00531             dinfo-&gt;float_depth = value[i];
<a name="l00532"></a>00532         }
<a name="l00533"></a>00533     }
<a name="l00534"></a>00534 
<a name="l00535"></a>00535     <span class="comment">/* This bit is the same as the X code, setting some things based on</span>
<a name="l00536"></a>00536 <span class="comment">     * what we&#39;ve read out of the PFD. */</span>
<a name="l00537"></a>00537     dinfo-&gt;colour_depth = 0;
<a name="l00538"></a>00538     <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.r == 5 &amp;&amp; dinfo-&gt;pixel_size.rgba.b == 5) {
<a name="l00539"></a>00539         <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.g == 5)
<a name="l00540"></a>00540             dinfo-&gt;colour_depth = 15;
<a name="l00541"></a>00541         <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.g == 6)
<a name="l00542"></a>00542             dinfo-&gt;colour_depth = 16;
<a name="l00543"></a>00543     }
<a name="l00544"></a>00544     <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.r == 8
<a name="l00545"></a>00545         &amp;&amp; dinfo-&gt;pixel_size.rgba.g == 8 &amp;&amp; dinfo-&gt;pixel_size.rgba.b == 8) {
<a name="l00546"></a>00546         <span class="keywordflow">if</span> (dinfo-&gt;pixel_size.rgba.a == 8)
<a name="l00547"></a>00547             dinfo-&gt;colour_depth = 32;
<a name="l00548"></a>00548         <span class="keywordflow">else</span>
<a name="l00549"></a>00549             dinfo-&gt;colour_depth = 24;
<a name="l00550"></a>00550     }
<a name="l00551"></a>00551 
<a name="l00552"></a>00552     dinfo-&gt;allegro_format = (dinfo-&gt;colour_depth != 0)
<a name="l00553"></a>00553         &amp;&amp; (dinfo-&gt;g_shift == dinfo-&gt;pixel_size.rgba.b)
<a name="l00554"></a>00554         &amp;&amp; (dinfo-&gt;r_shift * dinfo-&gt;b_shift == 0)
<a name="l00555"></a>00555         &amp;&amp; (dinfo-&gt;r_shift + dinfo-&gt;b_shift ==
<a name="l00556"></a>00556             dinfo-&gt;pixel_size.rgba.b + dinfo-&gt;pixel_size.rgba.g);
<a name="l00557"></a>00557 
<a name="l00558"></a>00558     <span class="keywordflow">return</span> 0;
<a name="l00559"></a>00559 }
<a name="l00560"></a>00560 
<a name="l00561"></a>00561 
<a name="l00562"></a>00562 
<a name="l00563"></a>00563 <span class="keyword">typedef</span> <span class="keyword">struct </span>format_t {
<a name="l00564"></a>00564     <span class="keywordtype">int</span> score;
<a name="l00565"></a>00565     <span class="keywordtype">int</span> format;
<a name="l00566"></a>00566 } format_t;
<a name="l00567"></a>00567 
<a name="l00568"></a>00568 
<a name="l00569"></a>00569 
<a name="l00570"></a>00570 <span class="comment">/* Helper function for sorting pixel formats by score */</span>
<a name="l00571"></a>00571 <span class="keyword">static</span> <span class="keywordtype">int</span> select_pixel_format_sorter(<span class="keyword">const</span> <span class="keywordtype">void</span> *p0, <span class="keyword">const</span> <span class="keywordtype">void</span> *p1) {
<a name="l00572"></a>00572     format_t *f0 = (format_t*)p0;
<a name="l00573"></a>00573     format_t *f1 = (format_t*)p1;
<a name="l00574"></a>00574 
<a name="l00575"></a>00575     <span class="keywordflow">if</span> (f0-&gt;score == f1-&gt;score) {
<a name="l00576"></a>00576         <span class="keywordflow">return</span> 0;
<a name="l00577"></a>00577     }
<a name="l00578"></a>00578     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (f0-&gt;score &gt; f1-&gt;score) {
<a name="l00579"></a>00579         <span class="keywordflow">return</span> -1;
<a name="l00580"></a>00580     }
<a name="l00581"></a>00581     <span class="keywordflow">else</span> {
<a name="l00582"></a>00582         <span class="keywordflow">return</span> 1;
<a name="l00583"></a>00583     }
<a name="l00584"></a>00584 }
<a name="l00585"></a>00585 
<a name="l00586"></a>00586 
<a name="l00587"></a>00587 
<a name="l00588"></a>00588 <span class="comment">/* Describes the pixel format and assigns it a score */</span>
<a name="l00589"></a>00589 <span class="keywordtype">int</span> describe_pixel_format_old(HDC dc, <span class="keywordtype">int</span> fmt, <span class="keywordtype">int</span> desktop_depth,
<a name="l00590"></a>00590                                format_t *formats, <span class="keywordtype">int</span> *num_formats,
<a name="l00591"></a>00591                                <span class="keyword">struct</span> allegro_gl_display_info *pdinfo) {
<a name="l00592"></a>00592 
<a name="l00593"></a>00593     <span class="keyword">struct </span>allegro_gl_display_info dinfo;
<a name="l00594"></a>00594     PIXELFORMATDESCRIPTOR pfd;
<a name="l00595"></a>00595     <span class="keywordtype">int</span> score = -1;
<a name="l00596"></a>00596     
<a name="l00597"></a>00597     <span class="keywordtype">int</span> result = DescribePixelFormat(dc, fmt, <span class="keyword">sizeof</span>(pfd), &amp;pfd);
<a name="l00598"></a>00598 
<a name="l00599"></a>00599     <span class="comment">/* Remember old settings */</span>
<a name="l00600"></a>00600     <span class="keywordflow">if</span> (pdinfo) {
<a name="l00601"></a>00601         dinfo = *pdinfo;
<a name="l00602"></a>00602     }
<a name="l00603"></a>00603 
<a name="l00604"></a>00604     <span class="keywordflow">if</span> (!result) {
<a name="l00605"></a>00605         log_win32_warning(<span class="stringliteral">&quot;describe_pixel_format_old&quot;</span>,
<a name="l00606"></a>00606                           <span class="stringliteral">&quot;DescribePixelFormat() failed!&quot;</span>, GetLastError());
<a name="l00607"></a>00607         <span class="keywordflow">return</span> -1;
<a name="l00608"></a>00608     }
<a name="l00609"></a>00609     
<a name="l00610"></a>00610     result = !decode_pixel_format(&amp;pfd, dc, fmt, &amp;dinfo, desktop_depth);
<a name="l00611"></a>00611     
<a name="l00612"></a>00612     <span class="keywordflow">if</span> (result) {
<a name="l00613"></a>00613         print_pixel_format(&amp;dinfo);
<a name="l00614"></a>00614         score = __allegro_gl_score_config(fmt, &amp;dinfo);
<a name="l00615"></a>00615     }
<a name="l00616"></a>00616             
<a name="l00617"></a>00617     <span class="keywordflow">if</span> (score &lt; 0) {
<a name="l00618"></a>00618         <span class="keywordflow">return</span> -1; <span class="comment">/* Reject non-compliant pixel formats */</span>
<a name="l00619"></a>00619     }
<a name="l00620"></a>00620 
<a name="l00621"></a>00621     <span class="keywordflow">if</span> (formats &amp;&amp; num_formats) {
<a name="l00622"></a>00622         formats[*num_formats].score  = score;
<a name="l00623"></a>00623         formats[*num_formats].format = fmt;
<a name="l00624"></a>00624         (*num_formats)++;
<a name="l00625"></a>00625     }
<a name="l00626"></a>00626 
<a name="l00627"></a>00627     <span class="keywordflow">if</span> (pdinfo) {
<a name="l00628"></a>00628         *pdinfo = dinfo;
<a name="l00629"></a>00629     }
<a name="l00630"></a>00630 
<a name="l00631"></a>00631     <span class="keywordflow">return</span> 0;
<a name="l00632"></a>00632 }
<a name="l00633"></a>00633 
<a name="l00634"></a>00634 
<a name="l00635"></a>00635 
<a name="l00636"></a>00636 <span class="keyword">static</span> AGL_GetPixelFormatAttribivARB_t __wglGetPixelFormatAttribivARB = NULL;
<a name="l00637"></a>00637 <span class="keyword">static</span> AGL_GetPixelFormatAttribivEXT_t __wglGetPixelFormatAttribivEXT = NULL;
<a name="l00638"></a>00638 
<a name="l00639"></a>00639 
<a name="l00640"></a>00640 
<a name="l00641"></a>00641 <span class="comment">/* Describes the pixel format and assigns it a score */</span>
<a name="l00642"></a>00642 <span class="keywordtype">int</span> describe_pixel_format_new(HDC dc, <span class="keywordtype">int</span> fmt, <span class="keywordtype">int</span> desktop_depth,
<a name="l00643"></a>00643                               format_t *formats, <span class="keywordtype">int</span> *num_formats,
<a name="l00644"></a>00644                               <span class="keyword">struct</span> allegro_gl_display_info *pdinfo) {
<a name="l00645"></a>00645 
<a name="l00646"></a>00646     <span class="keyword">struct </span>allegro_gl_display_info dinfo;
<a name="l00647"></a>00647     <span class="keywordtype">int</span> score = -1;
<a name="l00648"></a>00648 
<a name="l00649"></a>00649     <span class="comment">/* Note: Even though we use te ARB suffix, all those enums are compatible</span>
<a name="l00650"></a>00650 <span class="comment">     * with EXT_pixel_format.</span>
<a name="l00651"></a>00651 <span class="comment">     */</span>
<a name="l00652"></a>00652     <span class="keywordtype">int</span> attrib[] = {
<a name="l00653"></a>00653         WGL_SUPPORT_OPENGL_ARB,
<a name="l00654"></a>00654         WGL_DRAW_TO_WINDOW_ARB,
<a name="l00655"></a>00655         WGL_PIXEL_TYPE_ARB,
<a name="l00656"></a>00656         WGL_ACCELERATION_ARB,
<a name="l00657"></a>00657         WGL_DOUBLE_BUFFER_ARB,
<a name="l00658"></a>00658         WGL_DEPTH_BITS_ARB,
<a name="l00659"></a>00659         WGL_COLOR_BITS_ARB,
<a name="l00660"></a>00660         WGL_RED_BITS_ARB,
<a name="l00661"></a>00661         WGL_GREEN_BITS_ARB,
<a name="l00662"></a>00662         WGL_BLUE_BITS_ARB,
<a name="l00663"></a>00663         WGL_ALPHA_BITS_ARB,
<a name="l00664"></a>00664         WGL_RED_SHIFT_ARB,
<a name="l00665"></a>00665         WGL_GREEN_SHIFT_ARB,
<a name="l00666"></a>00666         WGL_BLUE_SHIFT_ARB,
<a name="l00667"></a>00667         WGL_ALPHA_SHIFT_ARB,
<a name="l00668"></a>00668         WGL_STENCIL_BITS_ARB,
<a name="l00669"></a>00669         WGL_STEREO_ARB,
<a name="l00670"></a>00670         WGL_ACCUM_BITS_ARB,
<a name="l00671"></a>00671         WGL_ACCUM_RED_BITS_ARB,
<a name="l00672"></a>00672         WGL_ACCUM_GREEN_BITS_ARB,
<a name="l00673"></a>00673         WGL_ACCUM_BLUE_BITS_ARB,
<a name="l00674"></a>00674         WGL_ACCUM_ALPHA_BITS_ARB,
<a name="l00675"></a>00675         WGL_AUX_BUFFERS_ARB,
<a name="l00676"></a>00676 
<a name="l00677"></a>00677         <span class="comment">/* The following are used by extensions that add to WGL_pixel_format.</span>
<a name="l00678"></a>00678 <span class="comment">         * If WGL_p_f isn&#39;t supported though, we can&#39;t use the (then invalid)</span>
<a name="l00679"></a>00679 <span class="comment">         * enums. We can&#39;t use any magic number either, so we settle for </span>
<a name="l00680"></a>00680 <span class="comment">         * replicating one. The pixel format decoder</span>
<a name="l00681"></a>00681 <span class="comment">         * (decode_pixel_format_attrib()) doesn&#39;t care about duplicates.</span>
<a name="l00682"></a>00682 <span class="comment">         */</span>
<a name="l00683"></a>00683         WGL_AUX_BUFFERS_ARB, <span class="comment">/* placeholder for WGL_SAMPLE_BUFFERS_ARB */</span>
<a name="l00684"></a>00684         WGL_AUX_BUFFERS_ARB, <span class="comment">/* placeholder for WGL_SAMPLES_ARB        */</span>
<a name="l00685"></a>00685         WGL_AUX_BUFFERS_ARB, <span class="comment">/* placeholder for WGL_DEPTH_FLOAT_EXT    */</span>
<a name="l00686"></a>00686     };
<a name="l00687"></a>00687 
<a name="l00688"></a>00688     <span class="keyword">const</span> <span class="keywordtype">int</span> num_attribs = <span class="keyword">sizeof</span>(attrib) / <span class="keyword">sizeof</span>(attrib[0]);
<a name="l00689"></a>00689     <span class="keywordtype">int</span> *value = (<span class="keywordtype">int</span>*)malloc(<span class="keyword">sizeof</span>(<span class="keywordtype">int</span>) * num_attribs);
<a name="l00690"></a>00690     <span class="keywordtype">int</span> result;
<a name="l00691"></a>00691     BOOL ret;
<a name="l00692"></a>00692     <span class="keywordtype">int</span> old_valid = __allegro_gl_valid_context;
<a name="l00693"></a>00693 
<a name="l00694"></a>00694     <span class="comment">/* Can&#39;t allocate mem? */</span>
<a name="l00695"></a>00695     <span class="keywordflow">if</span> (!value) {
<a name="l00696"></a>00696         TRACE(PREFIX_E <span class="stringliteral">&quot;describe_pixel_format_new(): Unable to allocate &quot;</span>
<a name="l00697"></a>00697               <span class="stringliteral">&quot;memory for pixel format descriptor!\n&quot;</span>);
<a name="l00698"></a>00698         <span class="keywordflow">return</span> -1;
<a name="l00699"></a>00699     }
<a name="l00700"></a>00700 
<a name="l00701"></a>00701     <span class="comment">/* Remember old settings */</span>
<a name="l00702"></a>00702     <span class="keywordflow">if</span> (pdinfo) {
<a name="l00703"></a>00703         dinfo = *pdinfo;
<a name="l00704"></a>00704     }
<a name="l00705"></a>00705     
<a name="l00706"></a>00706 
<a name="l00707"></a>00707     <span class="comment">/* If multisampling is supported, query for it. Note - we need to tell</span>
<a name="l00708"></a>00708 <span class="comment">     * allegro_gl_is_extension_supported() that we have a valid context,</span>
<a name="l00709"></a>00709 <span class="comment">     * even though AGL is not initialized yet.</span>
<a name="l00710"></a>00710 <span class="comment">     */</span>
<a name="l00711"></a>00711     __allegro_gl_valid_context = 1;
<a name="l00712"></a>00712     <span class="keywordflow">if</span> (<a class="code" href="group__extensions.html#ga7351f56ea1c4f4665193fc3bf547ff0a" title="This function is an helper to determine whether an OpenGL extension is available or not...">allegro_gl_is_extension_supported</a>(<span class="stringliteral">&quot;WGL_ARB_multisample&quot;</span>)) {
<a name="l00713"></a>00713         attrib[num_attribs - 3] = WGL_SAMPLE_BUFFERS_ARB;
<a name="l00714"></a>00714         attrib[num_attribs - 2] = WGL_SAMPLES_ARB;
<a name="l00715"></a>00715     }
<a name="l00716"></a>00716     <span class="keywordflow">if</span> (<a class="code" href="group__extensions.html#ga7351f56ea1c4f4665193fc3bf547ff0a" title="This function is an helper to determine whether an OpenGL extension is available or not...">allegro_gl_is_extension_supported</a>(<span class="stringliteral">&quot;WGL_EXT_depth_float&quot;</span>)) {
<a name="l00717"></a>00717         attrib[num_attribs - 1] = WGL_DEPTH_FLOAT_EXT;
<a name="l00718"></a>00718     }
<a name="l00719"></a>00719     __allegro_gl_valid_context = old_valid;
<a name="l00720"></a>00720 
<a name="l00721"></a>00721     
<a name="l00722"></a>00722     <span class="comment">/* Get the pf attributes */</span>
<a name="l00723"></a>00723     <span class="keywordflow">if</span> (__wglGetPixelFormatAttribivARB) {
<a name="l00724"></a>00724         ret = __wglGetPixelFormatAttribivARB(dc, fmt, 0, num_attribs,
<a name="l00725"></a>00725                                              attrib, value);
<a name="l00726"></a>00726     }
<a name="l00727"></a>00727     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (__wglGetPixelFormatAttribivEXT) {
<a name="l00728"></a>00728         ret = __wglGetPixelFormatAttribivEXT(dc, fmt, 0, num_attribs,
<a name="l00729"></a>00729                                              attrib, value);
<a name="l00730"></a>00730     }
<a name="l00731"></a>00731     <span class="keywordflow">else</span> {
<a name="l00732"></a>00732         ret = 0;
<a name="l00733"></a>00733     }   
<a name="l00734"></a>00734 
<a name="l00735"></a>00735     <span class="comment">/* wglGetPixelFormatAttrib() failed? Abort and revert to old path */</span>
<a name="l00736"></a>00736     <span class="keywordflow">if</span> (!ret) {
<a name="l00737"></a>00737         log_win32_error(<span class="stringliteral">&quot;describe_pixel_format_new&quot;</span>,
<a name="l00738"></a>00738                         <span class="stringliteral">&quot;wglGetPixelFormatAttrib failed!&quot;</span>, GetLastError());
<a name="l00739"></a>00739         free(value);
<a name="l00740"></a>00740         <span class="keywordflow">return</span> -1;
<a name="l00741"></a>00741     }
<a name="l00742"></a>00742 
<a name="l00743"></a>00743     <span class="comment">/* Convert to AllegroGL format for scoring */</span>
<a name="l00744"></a>00744     result = !decode_pixel_format_attrib(&amp;dinfo, num_attribs, attrib, value,
<a name="l00745"></a>00745                                          desktop_depth);
<a name="l00746"></a>00746     free(value);
<a name="l00747"></a>00747 
<a name="l00748"></a>00748     <span class="keywordflow">if</span> (result) {
<a name="l00749"></a>00749         print_pixel_format(&amp;dinfo); 
<a name="l00750"></a>00750         score = __allegro_gl_score_config(fmt, &amp;dinfo);
<a name="l00751"></a>00751     }
<a name="l00752"></a>00752 
<a name="l00753"></a>00753     <span class="keywordflow">if</span> (score &lt; 0) {
<a name="l00754"></a>00754         <span class="keywordflow">return</span> 0; <span class="comment">/* Reject non-compliant pixel formats */</span>
<a name="l00755"></a>00755     }
<a name="l00756"></a>00756 
<a name="l00757"></a>00757     <span class="keywordflow">if</span> (formats &amp;&amp; num_formats) {
<a name="l00758"></a>00758         formats[*num_formats].score  = score;
<a name="l00759"></a>00759         formats[*num_formats].format = fmt;
<a name="l00760"></a>00760         (*num_formats)++;
<a name="l00761"></a>00761     }
<a name="l00762"></a>00762 
<a name="l00763"></a>00763     <span class="keywordflow">if</span> (pdinfo) {
<a name="l00764"></a>00764         *pdinfo = dinfo;
<a name="l00765"></a>00765     }
<a name="l00766"></a>00766 
<a name="l00767"></a>00767     <span class="keywordflow">return</span> 0;
<a name="l00768"></a>00768 }
<a name="l00769"></a>00769 
<a name="l00770"></a>00770 
<a name="l00771"></a>00771 
<a name="l00772"></a>00772 <span class="comment">/* Returns the number of pixel formats we should investigate */</span>
<a name="l00773"></a>00773 <span class="keywordtype">int</span> get_num_pixel_formats(HDC dc, <span class="keywordtype">int</span> *new_pf_code) {
<a name="l00774"></a>00774     
<a name="l00775"></a>00775     <span class="comment">/* DescribePixelFormat() returns maximum pixel format index in the old</span>
<a name="l00776"></a>00776 <span class="comment">     * code. wglGetPixelFormatAttribivARB() does it in the new code.</span>
<a name="l00777"></a>00777 <span class="comment">     */</span>
<a name="l00778"></a>00778     <span class="keywordflow">if</span> (new_pf_code &amp;&amp; *new_pf_code) {
<a name="l00779"></a>00779         <span class="keywordtype">int</span> attrib[1];
<a name="l00780"></a>00780         <span class="keywordtype">int</span> value[1];
<a name="l00781"></a>00781         
<a name="l00782"></a>00782         TRACE(PREFIX_I <span class="stringliteral">&quot;get_num_pixel_formats(): Attempting to use WGL_pf.\n&quot;</span>);
<a name="l00783"></a>00783         attrib[0] = WGL_NUMBER_PIXEL_FORMATS_ARB;
<a name="l00784"></a>00784         <span class="keywordflow">if</span> ((__wglGetPixelFormatAttribivARB
<a name="l00785"></a>00785           &amp;&amp; __wglGetPixelFormatAttribivARB(dc, 0, 0, 1, attrib, value)
<a name="l00786"></a>00786                                                                  == GL_FALSE)
<a name="l00787"></a>00787          || (__wglGetPixelFormatAttribivEXT
<a name="l00788"></a>00788           &amp;&amp; __wglGetPixelFormatAttribivEXT(dc, 0, 0, 1, attrib, value)
<a name="l00789"></a>00789                                                                  == GL_FALSE)) {
<a name="l00790"></a>00790             log_win32_note(<span class="stringliteral">&quot;get_num_pixel_formats&quot;</span>,
<a name="l00791"></a>00791                         <span class="stringliteral">&quot;WGL_ARB/EXT_pixel_format use failed!&quot;</span>, GetLastError());
<a name="l00792"></a>00792             *new_pf_code = 0;
<a name="l00793"></a>00793         }
<a name="l00794"></a>00794         <span class="keywordflow">else</span> {
<a name="l00795"></a>00795             <span class="keywordflow">return</span> value[0];
<a name="l00796"></a>00796         }
<a name="l00797"></a>00797     }
<a name="l00798"></a>00798 
<a name="l00799"></a>00799     <span class="keywordflow">if</span> (!new_pf_code || !*new_pf_code) {
<a name="l00800"></a>00800         PIXELFORMATDESCRIPTOR pfd;
<a name="l00801"></a>00801         <span class="keywordtype">int</span> ret;
<a name="l00802"></a>00802         
<a name="l00803"></a>00803         TRACE(PREFIX_I <span class="stringliteral">&quot;get_num_pixel_formats(): Using DescribePixelFormat.\n&quot;</span>);
<a name="l00804"></a>00804         ret = DescribePixelFormat(dc, 1, <span class="keyword">sizeof</span>(pfd), &amp;pfd);
<a name="l00805"></a>00805 
<a name="l00806"></a>00806         <span class="keywordflow">if</span> (!ret) {
<a name="l00807"></a>00807             log_win32_error(<span class="stringliteral">&quot;get_num_pixel_formats&quot;</span>,
<a name="l00808"></a>00808                         <span class="stringliteral">&quot;DescribePixelFormat failed!&quot;</span>, GetLastError());
<a name="l00809"></a>00809         }
<a name="l00810"></a>00810         
<a name="l00811"></a>00811         <span class="keywordflow">return</span> ret;
<a name="l00812"></a>00812     }
<a name="l00813"></a>00813 
<a name="l00814"></a>00814     <span class="keywordflow">return</span> 0;
<a name="l00815"></a>00815 }
<a name="l00816"></a>00816 
<a name="l00817"></a>00817 
<a name="l00818"></a>00818 
<a name="l00819"></a>00819 <span class="comment">/* Pick the best matching pixel format */</span>
<a name="l00820"></a>00820 <span class="keyword">static</span> <span class="keywordtype">int</span> select_pixel_format(PIXELFORMATDESCRIPTOR * pfd)
<a name="l00821"></a>00821 {
<a name="l00822"></a>00822     <span class="keywordtype">int</span> i;
<a name="l00823"></a>00823     <span class="keywordtype">int</span> result, maxindex;
<a name="l00824"></a>00824     <span class="keywordtype">int</span> desktop_depth;
<a name="l00825"></a>00825 
<a name="l00826"></a>00826     HWND testwnd = NULL;
<a name="l00827"></a>00827     HDC testdc   = NULL;
<a name="l00828"></a>00828     HGLRC testrc = NULL;
<a name="l00829"></a>00829     
<a name="l00830"></a>00830     format_t *format = NULL;
<a name="l00831"></a>00831     <span class="keywordtype">int</span> num_formats = 0;
<a name="l00832"></a>00832     <span class="keywordtype">int</span> new_pf_code = 0;
<a name="l00833"></a>00833 
<a name="l00834"></a>00834     
<a name="l00835"></a>00835     __allegro_gl_reset_scorer();
<a name="l00836"></a>00836 
<a name="l00837"></a>00837     <span class="comment">/* Read again the desktop depth */</span>
<a name="l00838"></a>00838     desktop_depth = desktop_color_depth();
<a name="l00839"></a>00839  
<a name="l00840"></a>00840     <span class="keywordflow">if</span> (register_test_window() &lt; 0) {
<a name="l00841"></a>00841         <span class="keywordflow">return</span> 0;
<a name="l00842"></a>00842     }
<a name="l00843"></a>00843 
<a name="l00844"></a>00844     testwnd = create_test_window();
<a name="l00845"></a>00845 
<a name="l00846"></a>00846     <span class="keywordflow">if</span> (!testwnd) {
<a name="l00847"></a>00847         <span class="keywordflow">return</span> 0;
<a name="l00848"></a>00848     }
<a name="l00849"></a>00849 
<a name="l00850"></a>00850     testdc = GetDC(testwnd);
<a name="l00851"></a>00851 
<a name="l00852"></a>00852     <span class="comment">/* Check if we can support new pixel format code */</span>
<a name="l00853"></a>00853     TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): Trying to set up temporary RC\n&quot;</span>);
<a name="l00854"></a>00854     {
<a name="l00855"></a>00855         HDC old_dc = __allegro_gl_hdc;
<a name="l00856"></a>00856         <span class="keywordtype">int</span> old_valid = __allegro_gl_valid_context;
<a name="l00857"></a>00857         PIXELFORMATDESCRIPTOR pfd;
<a name="l00858"></a>00858         <span class="keywordtype">int</span> pf;
<a name="l00859"></a>00859         
<a name="l00860"></a>00860         new_pf_code = 0;
<a name="l00861"></a>00861         
<a name="l00862"></a>00862         <span class="comment">/* We need to create a dummy window with a pixel format to get the</span>
<a name="l00863"></a>00863 <span class="comment">         * list of valid PFDs</span>
<a name="l00864"></a>00864 <span class="comment">         */</span>
<a name="l00865"></a>00865         memset(&amp;pfd, 0, <span class="keyword">sizeof</span>(pfd));
<a name="l00866"></a>00866         pfd.nSize = <span class="keyword">sizeof</span>(pfd);
<a name="l00867"></a>00867         pfd.dwFlags = PFD_DRAW_TO_WINDOW | PFD_SUPPORT_OPENGL
<a name="l00868"></a>00868                     | PFD_DOUBLEBUFFER_DONTCARE | PFD_STEREO_DONTCARE;
<a name="l00869"></a>00869         pfd.iPixelType = PFD_TYPE_RGBA;
<a name="l00870"></a>00870         pfd.iLayerType = PFD_MAIN_PLANE;
<a name="l00871"></a>00871         pfd.cColorBits = 32;
<a name="l00872"></a>00872 
<a name="l00873"></a>00873         TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): ChoosePixelFormat()\n&quot;</span>);
<a name="l00874"></a>00874         pf = ChoosePixelFormat(testdc, &amp;pfd);
<a name="l00875"></a>00875 
<a name="l00876"></a>00876         <span class="keywordflow">if</span> (!pf) {
<a name="l00877"></a>00877             log_win32_warning(<span class="stringliteral">&quot;select_pixel_format&quot;</span>,
<a name="l00878"></a>00878                         <span class="stringliteral">&quot;Unable to chose a temporary pixel format!&quot;</span>,
<a name="l00879"></a>00879                         GetLastError());
<a name="l00880"></a>00880             <span class="keywordflow">goto</span> fail_pf;
<a name="l00881"></a>00881         }
<a name="l00882"></a>00882 
<a name="l00883"></a>00883         <span class="comment">/* Set up a GL context there */</span>
<a name="l00884"></a>00884         TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): SetPixelFormat()\n&quot;</span>);
<a name="l00885"></a>00885         memset(&amp;pfd, 0, <span class="keyword">sizeof</span>(pfd));
<a name="l00886"></a>00886         <span class="keywordflow">if</span> (!SetPixelFormat(testdc, pf, &amp;pfd)) {
<a name="l00887"></a>00887             log_win32_warning(<span class="stringliteral">&quot;select_pixel_format&quot;</span>,
<a name="l00888"></a>00888                         <span class="stringliteral">&quot;Unable to set a temporary pixel format!&quot;</span>,
<a name="l00889"></a>00889                         GetLastError());
<a name="l00890"></a>00890             <span class="keywordflow">goto</span> fail_pf;
<a name="l00891"></a>00891         }
<a name="l00892"></a>00892 
<a name="l00893"></a>00893         TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): CreateContext()\n&quot;</span>);
<a name="l00894"></a>00894         testrc = wglCreateContext(testdc);
<a name="l00895"></a>00895 
<a name="l00896"></a>00896         <span class="keywordflow">if</span> (!testrc) {
<a name="l00897"></a>00897             log_win32_warning(<span class="stringliteral">&quot;select_pixel_format&quot;</span>,
<a name="l00898"></a>00898                         <span class="stringliteral">&quot;Unable to create a render context!&quot;</span>,
<a name="l00899"></a>00899                         GetLastError());
<a name="l00900"></a>00900             <span class="keywordflow">goto</span> fail_pf;
<a name="l00901"></a>00901         }
<a name="l00902"></a>00902         
<a name="l00903"></a>00903         TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): MakeCurrent()\n&quot;</span>);
<a name="l00904"></a>00904         <span class="keywordflow">if</span> (!wglMakeCurrent(testdc, testrc)) {
<a name="l00905"></a>00905             log_win32_warning(<span class="stringliteral">&quot;select_pixel_format&quot;</span>,
<a name="l00906"></a>00906                         <span class="stringliteral">&quot;Unable to set the render context as current!&quot;</span>,
<a name="l00907"></a>00907                         GetLastError());
<a name="l00908"></a>00908             <span class="keywordflow">goto</span> fail_pf;
<a name="l00909"></a>00909         }
<a name="l00910"></a>00910 
<a name="l00911"></a>00911         __allegro_gl_hdc = testdc;
<a name="l00912"></a>00912         __allegro_gl_valid_context = TRUE;
<a name="l00913"></a>00913 
<a name="l00914"></a>00914 
<a name="l00915"></a>00915         <span class="comment">/* This is a workaround for a bug in old NVidia drivers. We need to</span>
<a name="l00916"></a>00916 <span class="comment">         * call wglGetExtensionsStringARB() for it to properly initialize.</span>
<a name="l00917"></a>00917 <span class="comment">         */</span>
<a name="l00918"></a>00918         TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): GetExtensionsStringARB()\n&quot;</span>);
<a name="l00919"></a>00919         <span class="keywordflow">if</span> (strstr((AL_CONST <span class="keywordtype">char</span>*)glGetString(GL_VENDOR), <span class="stringliteral">&quot;NVIDIA&quot;</span>)) {
<a name="l00920"></a>00920             AGL_GetExtensionsStringARB_t __wglGetExtensionsStringARB = NULL;
<a name="l00921"></a>00921             
<a name="l00922"></a>00922             __wglGetExtensionsStringARB = (AGL_GetExtensionsStringARB_t)
<a name="l00923"></a>00923                            wglGetProcAddress(<span class="stringliteral">&quot;wglGetExtensionsStringARB&quot;</span>);
<a name="l00924"></a>00924 
<a name="l00925"></a>00925             TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): Querying for &quot;</span>
<a name="l00926"></a>00926                   <span class="stringliteral">&quot;WGL_ARB_extension_string\n&quot;</span>);
<a name="l00927"></a>00927             
<a name="l00928"></a>00928             <span class="keywordflow">if</span> (__wglGetExtensionsStringARB) {
<a name="l00929"></a>00929                 TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): Calling &quot;</span>
<a name="l00930"></a>00930                       <span class="stringliteral">&quot;__wglGetExtensionsStringARB\n&quot;</span>);
<a name="l00931"></a>00931                 __wglGetExtensionsStringARB(testdc);
<a name="l00932"></a>00932             }
<a name="l00933"></a>00933         }
<a name="l00934"></a>00934 
<a name="l00935"></a>00935         
<a name="l00936"></a>00936         <span class="comment">/* Check that we support ARB/EXT_pixel_format */</span>
<a name="l00937"></a>00937         <span class="keywordflow">if</span> (!<a class="code" href="group__extensions.html#ga7351f56ea1c4f4665193fc3bf547ff0a" title="This function is an helper to determine whether an OpenGL extension is available or not...">allegro_gl_is_extension_supported</a>(<span class="stringliteral">&quot;WGL_ARB_pixel_format&quot;</span>)
<a name="l00938"></a>00938          &amp;&amp; !<a class="code" href="group__extensions.html#ga7351f56ea1c4f4665193fc3bf547ff0a" title="This function is an helper to determine whether an OpenGL extension is available or not...">allegro_gl_is_extension_supported</a>(<span class="stringliteral">&quot;WGL_EXT_pixel_format&quot;</span>)) {
<a name="l00939"></a>00939             TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): WGL_ARB/EXT_pf unsupported.\n&quot;</span>);
<a name="l00940"></a>00940             <span class="keywordflow">goto</span> fail_pf;
<a name="l00941"></a>00941         }
<a name="l00942"></a>00942         
<a name="l00943"></a>00943         <span class="comment">/* Load the ARB_p_f symbol - Note, we shouldn&#39;t use the AGL extension</span>
<a name="l00944"></a>00944 <span class="comment">         * mechanism here, because AGL hasn&#39;t been initialized yet!</span>
<a name="l00945"></a>00945 <span class="comment">         */</span>
<a name="l00946"></a>00946         TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): GetProcAddress()\n&quot;</span>);        
<a name="l00947"></a>00947         __wglGetPixelFormatAttribivARB = (AGL_GetPixelFormatAttribivARB_t)
<a name="l00948"></a>00948                        wglGetProcAddress(<span class="stringliteral">&quot;wglGetPixelFormatAttribivARB&quot;</span>);
<a name="l00949"></a>00949         __wglGetPixelFormatAttribivEXT = (AGL_GetPixelFormatAttribivEXT_t)
<a name="l00950"></a>00950                        wglGetProcAddress(<span class="stringliteral">&quot;wglGetPixelFormatAttribivEXT&quot;</span>);
<a name="l00951"></a>00951 
<a name="l00952"></a>00952         <span class="keywordflow">if</span> (!__wglGetPixelFormatAttribivARB
<a name="l00953"></a>00953          &amp;&amp; !__wglGetPixelFormatAttribivEXT) {
<a name="l00954"></a>00954             TRACE(PREFIX_E <span class="stringliteral">&quot;select_pixel_format(): WGL_ARB/EXT_pf not &quot;</span>
<a name="l00955"></a>00955                   <span class="stringliteral">&quot;correctly supported!\n&quot;</span>);
<a name="l00956"></a>00956             <span class="keywordflow">goto</span> fail_pf;
<a name="l00957"></a>00957         }
<a name="l00958"></a>00958 
<a name="l00959"></a>00959         new_pf_code = 1;
<a name="l00960"></a>00960         <span class="keywordflow">goto</span> exit_pf;
<a name="l00961"></a>00961 
<a name="l00962"></a>00962 fail_pf:
<a name="l00963"></a>00963         wglMakeCurrent(NULL, NULL);
<a name="l00964"></a>00964         <span class="keywordflow">if</span> (testrc) {
<a name="l00965"></a>00965             wglDeleteContext(testrc);
<a name="l00966"></a>00966         }
<a name="l00967"></a>00967         testrc = NULL;
<a name="l00968"></a>00968 
<a name="l00969"></a>00969         __wglGetPixelFormatAttribivARB = NULL;
<a name="l00970"></a>00970         __wglGetPixelFormatAttribivEXT = NULL;
<a name="l00971"></a>00971 exit_pf:
<a name="l00972"></a>00972         __allegro_gl_hdc = old_dc;
<a name="l00973"></a>00973         __allegro_gl_valid_context = old_valid;
<a name="l00974"></a>00974     }
<a name="l00975"></a>00975 
<a name="l00976"></a>00976     maxindex = get_num_pixel_formats(testdc, &amp;new_pf_code);
<a name="l00977"></a>00977 
<a name="l00978"></a>00978     <span class="comment">/* Check if using the new pf code failed. Likely due to driver bug.</span>
<a name="l00979"></a>00979 <span class="comment">     * maxindex is still valid though, so we can continue.</span>
<a name="l00980"></a>00980 <span class="comment">     */</span>
<a name="l00981"></a>00981     <span class="keywordflow">if</span> (!new_pf_code &amp;&amp; testrc) {
<a name="l00982"></a>00982         TRACE(PREFIX_W <span class="stringliteral">&quot;select_pixel_format(): WGL_ARB_pf call failed - &quot;</span>
<a name="l00983"></a>00983               <span class="stringliteral">&quot;reverted to plain old WGL.\n&quot;</span>);
<a name="l00984"></a>00984         wglMakeCurrent(NULL, NULL);
<a name="l00985"></a>00985         wglDeleteContext(testrc);
<a name="l00986"></a>00986         testrc  = NULL;
<a name="l00987"></a>00987         __wglGetPixelFormatAttribivARB = NULL;
<a name="l00988"></a>00988         __wglGetPixelFormatAttribivEXT = NULL;
<a name="l00989"></a>00989     }
<a name="l00990"></a>00990 
<a name="l00991"></a>00991     TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): %i formats.\n&quot;</span>, maxindex);
<a name="l00992"></a>00992 
<a name="l00993"></a>00993     <span class="keywordflow">if</span> (maxindex &lt; 1) {
<a name="l00994"></a>00994         TRACE(PREFIX_E <span class="stringliteral">&quot;select_pixel_format(): Didn&#39;t find any pixel &quot;</span>
<a name="l00995"></a>00995               <span class="stringliteral">&quot;formats at all!\n&quot;</span>);
<a name="l00996"></a>00996         <span class="keywordflow">goto</span> bail;
<a name="l00997"></a>00997     }
<a name="l00998"></a>00998     
<a name="l00999"></a>00999     format = malloc((maxindex + 1) * <span class="keyword">sizeof</span>(format_t));
<a name="l01000"></a>01000     
<a name="l01001"></a>01001     <span class="keywordflow">if</span> (!format) {
<a name="l01002"></a>01002         TRACE(PREFIX_E <span class="stringliteral">&quot;select_pixel_format(): Unable to allocate memory for &quot;</span>
<a name="l01003"></a>01003               <span class="stringliteral">&quot;pixel format scores!\n&quot;</span>);
<a name="l01004"></a>01004         <span class="keywordflow">goto</span> bail;
<a name="l01005"></a>01005     }
<a name="l01006"></a>01006 
<a name="l01007"></a>01007     <span class="comment">/* First, pixel formats are sorted by decreasing order */</span>
<a name="l01008"></a>01008     TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): Testing pixel formats:\n&quot;</span>);
<a name="l01009"></a>01009     <span class="keywordflow">for</span> (i = 1; i &lt;= maxindex; i++) {
<a name="l01010"></a>01010 
<a name="l01011"></a>01011         <span class="keywordtype">int</span> use_old = !new_pf_code;
<a name="l01012"></a>01012         
<a name="l01013"></a>01013         TRACE(PREFIX_I <span class="stringliteral">&quot;Format %i:\n&quot;</span>, i);
<a name="l01014"></a>01014         
<a name="l01015"></a>01015         <span class="keywordflow">if</span> (new_pf_code) {
<a name="l01016"></a>01016             <span class="keywordflow">if</span> (describe_pixel_format_new(testdc, i, desktop_depth,
<a name="l01017"></a>01017                                           format, &amp;num_formats, NULL) &lt; 0) {
<a name="l01018"></a>01018                 TRACE(PREFIX_W <span class="stringliteral">&quot;select_pixel_format(): Wasn&#39;t able to use &quot;</span>
<a name="l01019"></a>01019                       <span class="stringliteral">&quot;WGL_PixelFormat - reverting to old WGL code.\n&quot;</span>);
<a name="l01020"></a>01020                 use_old = 1;
<a name="l01021"></a>01021             }
<a name="l01022"></a>01022         }
<a name="l01023"></a>01023 
<a name="l01024"></a>01024         <span class="keywordflow">if</span> (use_old) {
<a name="l01025"></a>01025             <span class="keywordflow">if</span> (describe_pixel_format_old(testdc, i, desktop_depth,
<a name="l01026"></a>01026                                       format, &amp;num_formats, NULL) &lt; 0) {
<a name="l01027"></a>01027                 TRACE(PREFIX_W <span class="stringliteral">&quot;select_pixel_format(): Unable to rely on &quot;</span>
<a name="l01028"></a>01028                       <span class="stringliteral">&quot;unextended WGL to describe this pixelformat.\n&quot;</span>);
<a name="l01029"></a>01029             }
<a name="l01030"></a>01030         }
<a name="l01031"></a>01031     }
<a name="l01032"></a>01032 
<a name="l01033"></a>01033     <span class="keywordflow">if</span> (new_pf_code) {
<a name="l01034"></a>01034         wglMakeCurrent(NULL, NULL);
<a name="l01035"></a>01035         wglDeleteContext(testrc);
<a name="l01036"></a>01036         testrc = NULL;
<a name="l01037"></a>01037     }
<a name="l01038"></a>01038     <span class="keywordflow">if</span> (testwnd) {
<a name="l01039"></a>01039         ReleaseDC(testwnd, testdc);
<a name="l01040"></a>01040         testdc = NULL;
<a name="l01041"></a>01041         DestroyWindow(testwnd);
<a name="l01042"></a>01042         testwnd = NULL;
<a name="l01043"></a>01043     }
<a name="l01044"></a>01044 
<a name="l01045"></a>01045     <span class="keywordflow">if</span> (num_formats &lt; 1) {
<a name="l01046"></a>01046         TRACE(PREFIX_E <span class="stringliteral">&quot;select_pixel_format(): Didn&#39;t find any available &quot;</span>
<a name="l01047"></a>01047               <span class="stringliteral">&quot;pixel formats!\n&quot;</span>);
<a name="l01048"></a>01048         <span class="keywordflow">goto</span> bail;
<a name="l01049"></a>01049     }
<a name="l01050"></a>01050 
<a name="l01051"></a>01051     qsort(format, num_formats, <span class="keyword">sizeof</span>(format_t), select_pixel_format_sorter);
<a name="l01052"></a>01052 
<a name="l01053"></a>01053 
<a name="l01054"></a>01054     <span class="comment">/* Sorted pixel formats are tested until one of them succeeds to</span>
<a name="l01055"></a>01055 <span class="comment">     * make a GL context current */</span>
<a name="l01056"></a>01056     <span class="keywordflow">for</span> (i = 0; i &lt; num_formats ; i++) {
<a name="l01057"></a>01057         HGLRC rc;
<a name="l01058"></a>01058 
<a name="l01059"></a>01059         <span class="comment">/* Recreate our test windows */</span>
<a name="l01060"></a>01060         testwnd = create_test_window();
<a name="l01061"></a>01061         testdc = GetDC(testwnd);
<a name="l01062"></a>01062         
<a name="l01063"></a>01063         <span class="keywordflow">if</span> (SetPixelFormat(testdc, format[i].format, pfd)) {
<a name="l01064"></a>01064             rc = wglCreateContext(testdc);
<a name="l01065"></a>01065             <span class="keywordflow">if</span> (!rc) {
<a name="l01066"></a>01066                 TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): Unable to create RC!\n&quot;</span>);
<a name="l01067"></a>01067             }
<a name="l01068"></a>01068             <span class="keywordflow">else</span> {
<a name="l01069"></a>01069                 <span class="keywordflow">if</span> (wglMakeCurrent(testdc, rc)) {
<a name="l01070"></a>01070                     wglMakeCurrent(NULL, NULL);
<a name="l01071"></a>01071                     wglDeleteContext(rc);
<a name="l01072"></a>01072                     rc = NULL;
<a name="l01073"></a>01073 
<a name="l01074"></a>01074                     TRACE(PREFIX_I <span class="stringliteral">&quot;select_pixel_format(): Best config is: %i&quot;</span>
<a name="l01075"></a>01075                           <span class="stringliteral">&quot;\n&quot;</span>, format[i].format);
<a name="l01076"></a>01076 
<a name="l01077"></a>01077                     <span class="comment">/* XXX &lt;rohannessian&gt; DescribePixelFormat may fail on </span>
<a name="l01078"></a>01078 <span class="comment">                     * extended pixel format (WGL_ARB_p_f)</span>
<a name="l01079"></a>01079 <span class="comment">                     */</span>
<a name="l01080"></a>01080                     <span class="keywordflow">if</span> (!DescribePixelFormat(testdc, format[i].format,
<a name="l01081"></a>01081                                         <span class="keyword">sizeof</span> *pfd, pfd)) {
<a name="l01082"></a>01082                         TRACE(PREFIX_E <span class="stringliteral">&quot;Cannot describe this pixel format\n&quot;</span>);
<a name="l01083"></a>01083                         ReleaseDC(testwnd, testdc);
<a name="l01084"></a>01084                         DestroyWindow(testwnd);
<a name="l01085"></a>01085                         testdc = NULL;
<a name="l01086"></a>01086                         testwnd = NULL;
<a name="l01087"></a>01087                         <span class="keywordflow">continue</span>;
<a name="l01088"></a>01088                     }
<a name="l01089"></a>01089 
<a name="l01090"></a>01090                     ReleaseDC(testwnd, testdc);
<a name="l01091"></a>01091                     DestroyWindow(testwnd);
<a name="l01092"></a>01092 
<a name="l01093"></a>01093                     result = format[i].format;
<a name="l01094"></a>01094                     
<a name="l01095"></a>01095                     free(format);
<a name="l01096"></a>01096                     <span class="keywordflow">return</span> result;
<a name="l01097"></a>01097                 }
<a name="l01098"></a>01098                 <span class="keywordflow">else</span> {
<a name="l01099"></a>01099                     wglMakeCurrent(NULL, NULL);
<a name="l01100"></a>01100                     wglDeleteContext(rc);
<a name="l01101"></a>01101                     rc = NULL;
<a name="l01102"></a>01102                     log_win32_warning(<span class="stringliteral">&quot;select_pixel_format&quot;</span>,
<a name="l01103"></a>01103                             <span class="stringliteral">&quot;Couldn&#39;t make the temporary render context &quot;</span>
<a name="l01104"></a>01104                             <span class="stringliteral">&quot;current for the this pixel format.&quot;</span>,
<a name="l01105"></a>01105                             GetLastError());
<a name="l01106"></a>01106                 }
<a name="l01107"></a>01107             }
<a name="l01108"></a>01108         }
<a name="l01109"></a>01109         <span class="keywordflow">else</span> {
<a name="l01110"></a>01110             log_win32_note(<span class="stringliteral">&quot;select_pixel_format&quot;</span>,
<a name="l01111"></a>01111                         <span class="stringliteral">&quot;Unable to set pixel format!&quot;</span>, GetLastError());
<a name="l01112"></a>01112         }
<a name="l01113"></a>01113         
<a name="l01114"></a>01114         ReleaseDC(testwnd, testdc);
<a name="l01115"></a>01115         DestroyWindow(testwnd);
<a name="l01116"></a>01116         testdc = NULL;
<a name="l01117"></a>01117         testwnd = NULL;
<a name="l01118"></a>01118     }
<a name="l01119"></a>01119 
<a name="l01120"></a>01120     TRACE(PREFIX_E <span class="stringliteral">&quot;select_pixel_format(): All modes have failed...\n&quot;</span>);
<a name="l01121"></a>01121 bail:
<a name="l01122"></a>01122     <span class="keywordflow">if</span> (format) {
<a name="l01123"></a>01123         free(format);
<a name="l01124"></a>01124     }
<a name="l01125"></a>01125     <span class="keywordflow">if</span> (new_pf_code) {
<a name="l01126"></a>01126         wglMakeCurrent(NULL, NULL);
<a name="l01127"></a>01127         <span class="keywordflow">if</span> (testrc) {
<a name="l01128"></a>01128             wglDeleteContext(testrc);
<a name="l01129"></a>01129         }
<a name="l01130"></a>01130     }
<a name="l01131"></a>01131     <span class="keywordflow">if</span> (testwnd) {
<a name="l01132"></a>01132         ReleaseDC(testwnd, testdc);
<a name="l01133"></a>01133         DestroyWindow(testwnd);
<a name="l01134"></a>01134     }
<a name="l01135"></a>01135     
<a name="l01136"></a>01136     <span class="keywordflow">return</span> 0;
<a name="l01137"></a>01137 }
<a name="l01138"></a>01138 
<a name="l01139"></a>01139 
<a name="l01140"></a>01140 
<a name="l01141"></a>01141 <span class="keyword">static</span> <span class="keywordtype">void</span> allegrogl_init_window(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, DWORD style, DWORD exstyle)
<a name="l01142"></a>01142 {
<a name="l01143"></a>01143     RECT rect;
<a name="l01144"></a>01144 
<a name="l01145"></a>01145 <span class="preprocessor">#define req __allegro_gl_required_settings</span>
<a name="l01146"></a>01146 <span class="preprocessor"></span><span class="preprocessor">#define sug __allegro_gl_suggested_settings</span>
<a name="l01147"></a>01147 <span class="preprocessor"></span>
<a name="l01148"></a>01148     <span class="keywordtype">int</span> x = 32, y = 32;
<a name="l01149"></a>01149     
<a name="l01150"></a>01150     <span class="keywordflow">if</span> (req &amp; <a class="code" href="group__settings.html#gafea8132efd1fcac7a7f997ef0fe34cfa" title="Requests a placement of the window to a specified pixel location.">AGL_WINDOW_X</a> || sug &amp; <a class="code" href="group__settings.html#gafea8132efd1fcac7a7f997ef0fe34cfa" title="Requests a placement of the window to a specified pixel location.">AGL_WINDOW_X</a>)
<a name="l01151"></a>01151         x = allegro_gl_display_info.x;
<a name="l01152"></a>01152     <span class="keywordflow">if</span> (req &amp; <a class="code" href="group__settings.html#ga80b7ef911d06ddee6d94d528cc6d914a" title="Same as AGL_WINDOW_X, but for the y-axis.">AGL_WINDOW_Y</a> || sug &amp; <a class="code" href="group__settings.html#ga80b7ef911d06ddee6d94d528cc6d914a" title="Same as AGL_WINDOW_X, but for the y-axis.">AGL_WINDOW_Y</a>)
<a name="l01153"></a>01153         y = allegro_gl_display_info.y;
<a name="l01154"></a>01154 
<a name="l01155"></a>01155 <span class="preprocessor">#undef req</span>
<a name="l01156"></a>01156 <span class="preprocessor"></span><span class="preprocessor">#undef sug</span>
<a name="l01157"></a>01157 <span class="preprocessor"></span>    
<a name="l01158"></a>01158     <span class="keywordflow">if</span> (!fullscreen) {
<a name="l01159"></a>01159         rect.left = x;
<a name="l01160"></a>01160         rect.right = x + w;
<a name="l01161"></a>01161         rect.top = y;
<a name="l01162"></a>01162         rect.bottom = y + h;
<a name="l01163"></a>01163     }
<a name="l01164"></a>01164     <span class="keywordflow">else</span> {
<a name="l01165"></a>01165         rect.left = 0;
<a name="l01166"></a>01166         rect.right = w;
<a name="l01167"></a>01167         rect.top  = 0;
<a name="l01168"></a>01168         rect.bottom = h;
<a name="l01169"></a>01169     }
<a name="l01170"></a>01170 
<a name="l01171"></a>01171     <span class="comment">/* save original Allegro styles */</span>
<a name="l01172"></a>01172     style_saved = GetWindowLong(wnd, GWL_STYLE);
<a name="l01173"></a>01173     exstyle_saved = GetWindowLong(wnd, GWL_EXSTYLE);
<a name="l01174"></a>01174 
<a name="l01175"></a>01175     <span class="comment">/* set custom AllegroGL style */</span>
<a name="l01176"></a>01176     SetWindowLong(wnd, GWL_STYLE, style);
<a name="l01177"></a>01177     SetWindowLong(wnd, GWL_EXSTYLE, exstyle);
<a name="l01178"></a>01178 
<a name="l01179"></a>01179     <span class="keywordflow">if</span> (!fullscreen) {
<a name="l01180"></a>01180         AdjustWindowRectEx(&amp;rect, style, FALSE, exstyle);
<a name="l01181"></a>01181     }
<a name="l01182"></a>01182 
<a name="l01183"></a>01183     <span class="comment">/* make the changes visible */</span>
<a name="l01184"></a>01184     SetWindowPos(wnd, 0, rect.left, rect.top,
<a name="l01185"></a>01185         rect.right - rect.left, rect.bottom - rect.top,
<a name="l01186"></a>01186         SWP_NOZORDER | SWP_FRAMECHANGED);
<a name="l01187"></a>01187     
<a name="l01188"></a>01188     <span class="keywordflow">return</span>;
<a name="l01189"></a>01189 }
<a name="l01190"></a>01190 
<a name="l01191"></a>01191 
<a name="l01192"></a>01192 
<a name="l01193"></a>01193 <span class="keyword">static</span> BITMAP *allegro_gl_create_screen (GFX_DRIVER *drv, <span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h,
<a name="l01194"></a>01194                                          <span class="keywordtype">int</span> depth)
<a name="l01195"></a>01195 {
<a name="l01196"></a>01196     BITMAP *bmp;
<a name="l01197"></a>01197     <span class="keywordtype">int</span> is_linear = drv-&gt;linear;
<a name="l01198"></a>01198 
<a name="l01199"></a>01199     drv-&gt;linear = 1;
<a name="l01200"></a>01200     bmp = _make_bitmap (w, h, 0, drv, depth, 0);
<a name="l01201"></a>01201     
<a name="l01202"></a>01202     <span class="keywordflow">if</span> (!bmp) {
<a name="l01203"></a>01203         <span class="keywordflow">return</span> NULL;
<a name="l01204"></a>01204     }
<a name="l01205"></a>01205 
<a name="l01206"></a>01206     bmp-&gt;id = BMP_ID_VIDEO | 1000;
<a name="l01207"></a>01207     drv-&gt;linear = is_linear;
<a name="l01208"></a>01208 
<a name="l01209"></a>01209     drv-&gt;w = w;
<a name="l01210"></a>01210     drv-&gt;h = h;
<a name="l01211"></a>01211 
<a name="l01212"></a>01212     <span class="keywordflow">return</span> bmp;
<a name="l01213"></a>01213 }
<a name="l01214"></a>01214 
<a name="l01215"></a>01215 
<a name="l01216"></a>01216 <span class="keyword">static</span> LRESULT CALLBACK dummy_wnd_proc(HWND wnd, UINT message, WPARAM wparam, LPARAM lparam)
<a name="l01217"></a>01217 {
<a name="l01218"></a>01218     <span class="keywordflow">return</span> DefWindowProc(wnd, message, wparam, lparam);
<a name="l01219"></a>01219 }
<a name="l01220"></a>01220 
<a name="l01221"></a>01221 <span class="keyword">static</span> HWND dummy_wnd;
<a name="l01222"></a>01222 
<a name="l01223"></a>01223 <span class="keyword">static</span> <span class="keywordtype">void</span> dummy_window(<span class="keywordtype">void</span>)
<a name="l01224"></a>01224 {
<a name="l01225"></a>01225     WNDCLASS wnd_class;
<a name="l01226"></a>01226 
<a name="l01227"></a>01227     wnd_class.style = CS_HREDRAW | CS_VREDRAW;
<a name="l01228"></a>01228     wnd_class.lpfnWndProc = dummy_wnd_proc;
<a name="l01229"></a>01229     wnd_class.cbClsExtra = 0;
<a name="l01230"></a>01230     wnd_class.cbWndExtra = 0;
<a name="l01231"></a>01231     wnd_class.hInstance = GetModuleHandle(NULL);
<a name="l01232"></a>01232     wnd_class.hIcon = LoadIcon(NULL, IDI_APPLICATION);
<a name="l01233"></a>01233     wnd_class.hCursor = LoadCursor(NULL, IDC_ARROW);
<a name="l01234"></a>01234     wnd_class.hbrBackground = NULL;
<a name="l01235"></a>01235     wnd_class.lpszMenuName = NULL;
<a name="l01236"></a>01236     wnd_class.lpszClassName = <span class="stringliteral">&quot;allegro focus&quot;</span>;
<a name="l01237"></a>01237 
<a name="l01238"></a>01238     RegisterClass(&amp;wnd_class);
<a name="l01239"></a>01239 
<a name="l01240"></a>01240     dummy_wnd = CreateWindow(<span class="stringliteral">&quot;allegro focus&quot;</span>, <span class="stringliteral">&quot;Allegro&quot;</span>, WS_POPUP | WS_VISIBLE,
<a name="l01241"></a>01241             0, 0, 200, 200,
<a name="l01242"></a>01242             NULL, NULL, GetModuleHandle(NULL), NULL);
<a name="l01243"></a>01243 
<a name="l01244"></a>01244     ShowWindow(dummy_wnd, SW_SHOWNORMAL);
<a name="l01245"></a>01245     SetForegroundWindow(dummy_wnd);
<a name="l01246"></a>01246 }
<a name="l01247"></a>01247 
<a name="l01248"></a>01248 <span class="keyword">static</span> <span class="keywordtype">void</span> remove_dummy_window(<span class="keywordtype">void</span>)
<a name="l01249"></a>01249 {
<a name="l01250"></a>01250     DestroyWindow(dummy_wnd);
<a name="l01251"></a>01251     UnregisterClass(<span class="stringliteral">&quot;allegro focus&quot;</span>, GetModuleHandle(NULL));
<a name="l01252"></a>01252 }
<a name="l01253"></a>01253 
<a name="l01254"></a>01254 
<a name="l01255"></a>01255 <span class="keyword">static</span> BITMAP *allegro_gl_win_init(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> v_w, <span class="keywordtype">int</span> v_h)
<a name="l01256"></a>01256 {
<a name="l01257"></a>01257     <span class="keyword">static</span> <span class="keywordtype">int</span> first_time = 1;
<a name="l01258"></a>01258     
<a name="l01259"></a>01259     DWORD style=0, exstyle=0;
<a name="l01260"></a>01260     <span class="keywordtype">int</span> refresh_rate = _refresh_rate_request;
<a name="l01261"></a>01261     <span class="keywordtype">int</span> desktop_depth;
<a name="l01262"></a>01262     <span class="keywordtype">int</span> pf=0;
<a name="l01263"></a>01263 
<a name="l01264"></a>01264     new_w = w;
<a name="l01265"></a>01265     new_h = h;
<a name="l01266"></a>01266 
<a name="l01267"></a>01267     <span class="comment">/* virtual screen are not supported */</span>
<a name="l01268"></a>01268     <span class="keywordflow">if</span> ((v_w != 0 &amp;&amp; v_w != w) || (v_h != 0 &amp;&amp; v_h != h)) {
<a name="l01269"></a>01269         TRACE(PREFIX_E <span class="stringliteral">&quot;win_init(): Virtual screens are not supported in &quot;</span>
<a name="l01270"></a>01270               <span class="stringliteral">&quot;AllegroGL!\n&quot;</span>);
<a name="l01271"></a>01271         <span class="keywordflow">return</span> NULL;
<a name="l01272"></a>01272     }
<a name="l01273"></a>01273         
<a name="l01274"></a>01274     <span class="comment">/* Fill in missing color depth info */</span>
<a name="l01275"></a>01275     __allegro_gl_fill_in_info();
<a name="l01276"></a>01276 
<a name="l01277"></a>01277     <span class="comment">/* Be sure the current desktop color depth is at least 15bpp */</span>
<a name="l01278"></a>01278     <span class="comment">/* We may want to change this, so try to set a better depth, or</span>
<a name="l01279"></a>01279 <span class="comment">       to at least report an error somehow */</span>
<a name="l01280"></a>01280     desktop_depth = desktop_color_depth();
<a name="l01281"></a>01281 
<a name="l01282"></a>01282     <span class="keywordflow">if</span> (desktop_depth &lt; 15)
<a name="l01283"></a>01283         <span class="keywordflow">return</span> NULL;
<a name="l01284"></a>01284 
<a name="l01285"></a>01285     TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): Requested color depth: %i  &quot;</span>
<a name="l01286"></a>01286           <span class="stringliteral">&quot;Desktop color depth: %i\n&quot;</span>, allegro_gl_display_info.colour_depth,
<a name="l01287"></a>01287           desktop_depth);
<a name="l01288"></a>01288 
<a name="l01289"></a>01289         <span class="comment">/* In the moment the main window is destroyed, Allegro loses focus, and</span>
<a name="l01290"></a>01290 <span class="comment">         * focus can only be returned by actual user input under Windows XP. So</span>
<a name="l01291"></a>01291 <span class="comment">         * we need to create a dummy window which retains focus for us, until</span>
<a name="l01292"></a>01292 <span class="comment">         * the new window is up.</span>
<a name="l01293"></a>01293 <span class="comment">         */</span>
<a name="l01294"></a>01294         <span class="keywordflow">if</span> (fullscreen) dummy_window();
<a name="l01295"></a>01295 
<a name="l01296"></a>01296     <span class="comment">/* Need to set the w and h driver members at this point to avoid assertion</span>
<a name="l01297"></a>01297 <span class="comment">     * failure in set_mouse_range() when win_set_window() is called.</span>
<a name="l01298"></a>01298 <span class="comment">     */</span>
<a name="l01299"></a>01299     <span class="keywordflow">if</span> (fullscreen) {
<a name="l01300"></a>01300         gfx_allegro_gl_fullscreen.w = w;
<a name="l01301"></a>01301         gfx_allegro_gl_fullscreen.h = h;
<a name="l01302"></a>01302     }
<a name="l01303"></a>01303     <span class="keywordflow">else</span> {
<a name="l01304"></a>01304         gfx_allegro_gl_windowed.w = w;
<a name="l01305"></a>01305         gfx_allegro_gl_windowed.h = h;
<a name="l01306"></a>01306     }
<a name="l01307"></a>01307 
<a name="l01308"></a>01308     <span class="comment">/* request a fresh new window from Allegro... */</span>
<a name="l01309"></a>01309     <span class="comment">/* Set a NULL window to get Allegro to generate a new HWND. This is needed</span>
<a name="l01310"></a>01310 <span class="comment">     * because we can only set the pixel format once per window. Thus, calling</span>
<a name="l01311"></a>01311 <span class="comment">     * set_gfx_mode() multiple times will fail without this code.</span>
<a name="l01312"></a>01312 <span class="comment">     */</span>
<a name="l01313"></a>01313     <span class="keywordflow">if</span> (!first_time) {
<a name="l01314"></a>01314         win_set_window(NULL);
<a name="l01315"></a>01315     }
<a name="l01316"></a>01316     first_time = 0;
<a name="l01317"></a>01317 
<a name="l01318"></a>01318     <span class="comment">/* ...and retrieve its handle */</span>
<a name="l01319"></a>01319     wnd = win_get_window();
<a name="l01320"></a>01320     <span class="keywordflow">if</span> (!wnd)
<a name="l01321"></a>01321         <span class="keywordflow">return</span> NULL;
<a name="l01322"></a>01322 
<a name="l01323"></a>01323     <span class="comment">/* set up the AllegroGL window */</span>
<a name="l01324"></a>01324     <span class="keywordflow">if</span> (fullscreen) {
<a name="l01325"></a>01325         style = WS_POPUP | WS_CLIPCHILDREN | WS_CLIPSIBLINGS;
<a name="l01326"></a>01326         exstyle = WS_EX_APPWINDOW | WS_EX_TOPMOST;
<a name="l01327"></a>01327     }
<a name="l01328"></a>01328     <span class="keywordflow">else</span> {
<a name="l01329"></a>01329         style = WS_SYSMENU | WS_CAPTION | WS_MINIMIZEBOX | WS_CLIPCHILDREN
<a name="l01330"></a>01330               | WS_CLIPSIBLINGS;
<a name="l01331"></a>01331         exstyle = WS_EX_APPWINDOW | WS_EX_WINDOWEDGE;
<a name="l01332"></a>01332     }
<a name="l01333"></a>01333 
<a name="l01334"></a>01334     TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): Setting up window.\n&quot;</span>);
<a name="l01335"></a>01335     allegrogl_init_window(w, h, style, exstyle);
<a name="l01336"></a>01336 
<a name="l01337"></a>01337     __allegro_gl_hdc = GetDC(wnd); <span class="comment">/* get the device context of our window */</span>
<a name="l01338"></a>01338     <span class="keywordflow">if</span> (!__allegro_gl_hdc) {
<a name="l01339"></a>01339         <span class="keywordflow">goto</span> Error;
<a name="l01340"></a>01340     }
<a name="l01341"></a>01341 
<a name="l01342"></a>01342     TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): Driver selected fullscreen: %s\n&quot;</span>,
<a name="l01343"></a>01343           fullscreen ? <span class="stringliteral">&quot;Yes&quot;</span> : <span class="stringliteral">&quot;No&quot;</span>);
<a name="l01344"></a>01344 
<a name="l01345"></a>01345     <span class="keywordflow">if</span> (fullscreen)
<a name="l01346"></a>01346     {
<a name="l01347"></a>01347         DEVMODE dm;
<a name="l01348"></a>01348         DEVMODE fallback_dm;
<a name="l01349"></a>01349         <span class="keywordtype">int</span> fallback_dm_valid = 0;
<a name="l01350"></a>01350 
<a name="l01351"></a>01351         <span class="keywordtype">int</span> bpp_to_check[] = {16, 32, 24, 15, 0};
<a name="l01352"></a>01352         <span class="keywordtype">int</span> bpp_checked[] = {0, 0, 0, 0, 0};
<a name="l01353"></a>01353         <span class="keywordtype">int</span> bpp_index = 0;
<a name="l01354"></a>01354         <span class="keywordtype">int</span> i, j, result, modeswitch, done = 0;
<a name="l01355"></a>01355 
<a name="l01356"></a>01356         <span class="keywordflow">for</span> (j = 0; j &lt; 4; j++)
<a name="l01357"></a>01357         {
<a name="l01358"></a>01358             <span class="keywordflow">if</span> (bpp_to_check[j] == <a class="code" href="group__settings.html#ga2179291ddb3cb528c3c0cf84af5c51a9" title="Reads the setting of a configuration option.">allegro_gl_get</a>(<a class="code" href="group__settings.html#ga71846e567336fe02f8f063af1282ddc5" title="Specify the total color depth of the frame buffer.">AGL_COLOR_DEPTH</a>))
<a name="l01359"></a>01359             {
<a name="l01360"></a>01360                 bpp_index = j;
<a name="l01361"></a>01361                 <span class="keywordflow">break</span>;
<a name="l01362"></a>01362             }
<a name="l01363"></a>01363         }
<a name="l01364"></a>01364 
<a name="l01365"></a>01365         dm.dmSize = <span class="keyword">sizeof</span>(DEVMODE);
<a name="l01366"></a>01366         dm_saved.dmSize = <span class="keyword">sizeof</span>(DEVMODE);
<a name="l01367"></a>01367         
<a name="l01368"></a>01368         <span class="comment">/* Save old mode */</span>
<a name="l01369"></a>01369         EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &amp;dm_saved);
<a name="l01370"></a>01370         dm.dmBitsPerPel = desktop_depth; <span class="comment">/* Go around Win95&#39;s bug */</span>
<a name="l01371"></a>01371 
<a name="l01372"></a>01372         <span class="keywordflow">do</span>
<a name="l01373"></a>01373         {
<a name="l01374"></a>01374             <span class="keywordflow">if</span> (!bpp_to_check[bpp_index])
<a name="l01375"></a>01375             {
<a name="l01376"></a>01376                 TRACE(PREFIX_E <span class="stringliteral">&quot;win_init(): No more color depths to test.\n&quot;</span>
<a name="l01377"></a>01377                       <span class="stringliteral">&quot;\tUnable to find appropriate full screen mode and pixel &quot;</span>
<a name="l01378"></a>01378                       <span class="stringliteral">&quot;format.\n&quot;</span>);
<a name="l01379"></a>01379                 <span class="keywordflow">goto</span> Error;
<a name="l01380"></a>01380             }
<a name="l01381"></a>01381 
<a name="l01382"></a>01382             TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): Testing color depth: %i\n&quot;</span>,
<a name="l01383"></a>01383                   bpp_to_check[bpp_index]);
<a name="l01384"></a>01384             
<a name="l01385"></a>01385             memset(&amp;dm, 0, <span class="keyword">sizeof</span>(DEVMODE));
<a name="l01386"></a>01386             dm.dmSize = <span class="keyword">sizeof</span>(DEVMODE);
<a name="l01387"></a>01387             
<a name="l01388"></a>01388             i = 0;
<a name="l01389"></a>01389             <span class="keywordflow">do</span> 
<a name="l01390"></a>01390             {
<a name="l01391"></a>01391                 modeswitch = EnumDisplaySettings(NULL, i, &amp;dm);
<a name="l01392"></a>01392                 <span class="keywordflow">if</span> (!modeswitch)
<a name="l01393"></a>01393                     <span class="keywordflow">break</span>;
<a name="l01394"></a>01394 
<a name="l01395"></a>01395                 <span class="keywordflow">if</span> ((dm.dmPelsWidth  == (<span class="keywordtype">unsigned</span>) w)
<a name="l01396"></a>01396                  &amp;&amp; (dm.dmPelsHeight == (<span class="keywordtype">unsigned</span>) h)
<a name="l01397"></a>01397                  &amp;&amp; (dm.dmBitsPerPel == (<span class="keywordtype">unsigned</span>) bpp_to_check[bpp_index])
<a name="l01398"></a>01398                  &amp;&amp; (dm.dmDisplayFrequency != (<span class="keywordtype">unsigned</span>) refresh_rate)) {
<a name="l01399"></a>01399                     <span class="comment">/* Keep it as fallback if refresh rate request could not</span>
<a name="l01400"></a>01400 <span class="comment">                     * be satisfied. Try to get as close to 60Hz as possible though,</span>
<a name="l01401"></a>01401 <span class="comment">                     * it&#39;s a bit better for a fallback than just blindly picking</span>
<a name="l01402"></a>01402 <span class="comment">                     * something like 47Hz or 200Hz.</span>
<a name="l01403"></a>01403 <span class="comment">                     */</span>
<a name="l01404"></a>01404                     <span class="keywordflow">if</span> (!fallback_dm_valid) {
<a name="l01405"></a>01405                         fallback_dm = dm;
<a name="l01406"></a>01406                         fallback_dm_valid = 1;
<a name="l01407"></a>01407                     }
<a name="l01408"></a>01408                     <span class="keywordflow">else</span> <span class="keywordflow">if</span> (dm.dmDisplayFrequency &gt;= 60) {
<a name="l01409"></a>01409                         <span class="keywordflow">if</span> (dm.dmDisplayFrequency &lt; fallback_dm.dmDisplayFrequency) {
<a name="l01410"></a>01410                             fallback_dm = dm;
<a name="l01411"></a>01411                         }
<a name="l01412"></a>01412                     }
<a name="l01413"></a>01413                 }
<a name="l01414"></a>01414         
<a name="l01415"></a>01415                 i++;
<a name="l01416"></a>01416             }
<a name="l01417"></a>01417             <span class="keywordflow">while</span> ((dm.dmPelsWidth  != (<span class="keywordtype">unsigned</span>) w)
<a name="l01418"></a>01418                 || (dm.dmPelsHeight != (<span class="keywordtype">unsigned</span>) h)
<a name="l01419"></a>01419                 || (dm.dmBitsPerPel != (<span class="keywordtype">unsigned</span>) bpp_to_check[bpp_index])
<a name="l01420"></a>01420                 || (dm.dmDisplayFrequency != (<span class="keywordtype">unsigned</span>) refresh_rate));
<a name="l01421"></a>01421 
<a name="l01422"></a>01422             <span class="keywordflow">if</span> (!modeswitch &amp;&amp; !fallback_dm_valid) {
<a name="l01423"></a>01423                 TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): Unable to set mode, continuing &quot;</span>
<a name="l01424"></a>01424                       <span class="stringliteral">&quot;with next color depth\n&quot;</span>);
<a name="l01425"></a>01425             }
<a name="l01426"></a>01426             <span class="keywordflow">else</span> {
<a name="l01427"></a>01427                 <span class="keywordflow">if</span> (!modeswitch &amp;&amp; fallback_dm_valid)
<a name="l01428"></a>01428                     dm = fallback_dm;
<a name="l01429"></a>01429 
<a name="l01430"></a>01430                 TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): bpp_to_check[bpp_index] = %i\n&quot;</span>,
<a name="l01431"></a>01431                       bpp_to_check[bpp_index]);
<a name="l01432"></a>01432                 TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): dm.dmBitsPerPel = %i\n&quot;</span>,
<a name="l01433"></a>01433                       (<span class="keywordtype">int</span>)dm.dmBitsPerPel);
<a name="l01434"></a>01434 
<a name="l01435"></a>01435                 dm.dmFields = DM_PELSWIDTH | DM_PELSHEIGHT | DM_BITSPERPEL
<a name="l01436"></a>01436                             | DM_DISPLAYFREQUENCY;
<a name="l01437"></a>01437 
<a name="l01438"></a>01438                 result = ChangeDisplaySettings(&amp;dm, CDS_FULLSCREEN);
<a name="l01439"></a>01439 
<a name="l01440"></a>01440                 <span class="keywordflow">if</span> (result == DISP_CHANGE_SUCCESSFUL) 
<a name="l01441"></a>01441                 {
<a name="l01442"></a>01442                     TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): Setting pixel format.\n&quot;</span>);
<a name="l01443"></a>01443                     pf = select_pixel_format(&amp;pfd);
<a name="l01444"></a>01444                     <span class="keywordflow">if</span> (pf) {
<a name="l01445"></a>01445                         TRACE(PREFIX_I <span class="stringliteral">&quot;mode found\n&quot;</span>);
<a name="l01446"></a>01446                         _set_current_refresh_rate(dm.dmDisplayFrequency);
<a name="l01447"></a>01447                         done = 1;
<a name="l01448"></a>01448                     }
<a name="l01449"></a>01449                     <span class="keywordflow">else</span> {
<a name="l01450"></a>01450                         TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): Couldn&#39;t find compatible &quot;</span>
<a name="l01451"></a>01451                               <span class="stringliteral">&quot;GL context. Trying another screen mode.\n&quot;</span>);
<a name="l01452"></a>01452                     }
<a name="l01453"></a>01453                 }
<a name="l01454"></a>01454             }
<a name="l01455"></a>01455 
<a name="l01456"></a>01456             fallback_dm_valid = 0;
<a name="l01457"></a>01457             bpp_checked[bpp_index] = 1;
<a name="l01458"></a>01458 
<a name="l01459"></a>01459             bpp_index = 0;
<a name="l01460"></a>01460             <span class="keywordflow">while</span> (bpp_checked[bpp_index]) {
<a name="l01461"></a>01461                 bpp_index++;
<a name="l01462"></a>01462             }
<a name="l01463"></a>01463         } <span class="keywordflow">while</span> (!done);
<a name="l01464"></a>01464     }
<a name="l01465"></a>01465     <span class="keywordflow">else</span> {
<a name="l01466"></a>01466         DEVMODE dm;
<a name="l01467"></a>01467 
<a name="l01468"></a>01468         memset(&amp;dm, 0, <span class="keyword">sizeof</span>(DEVMODE));
<a name="l01469"></a>01469         dm.dmSize = <span class="keyword">sizeof</span>(DEVMODE);
<a name="l01470"></a>01470         <span class="keywordflow">if</span> (EnumDisplaySettings(NULL, ENUM_CURRENT_SETTINGS, &amp;dm) != 0) {
<a name="l01471"></a>01471             _set_current_refresh_rate(dm.dmDisplayFrequency);
<a name="l01472"></a>01472         }
<a name="l01473"></a>01473     }
<a name="l01474"></a>01474 
<a name="l01475"></a>01475     <span class="keywordflow">if</span> (!fullscreen) {
<a name="l01476"></a>01476         TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): Setting pixel format.\n&quot;</span>);
<a name="l01477"></a>01477         pf = select_pixel_format(&amp;pfd);
<a name="l01478"></a>01478         <span class="keywordflow">if</span> (pf == 0)
<a name="l01479"></a>01479             <span class="keywordflow">goto</span> Error;
<a name="l01480"></a>01480     }
<a name="l01481"></a>01481 
<a name="l01482"></a>01482     <span class="comment">/* set the pixel format */</span>
<a name="l01483"></a>01483     <span class="keywordflow">if</span> (!SetPixelFormat(__allegro_gl_hdc, pf, &amp;pfd)) { 
<a name="l01484"></a>01484         log_win32_error(<span class="stringliteral">&quot;win_init&quot;</span>,
<a name="l01485"></a>01485                     <span class="stringliteral">&quot;Unable to set pixel format.&quot;</span>,
<a name="l01486"></a>01486                     GetLastError());
<a name="l01487"></a>01487         <span class="keywordflow">goto</span> Error;
<a name="l01488"></a>01488     }
<a name="l01489"></a>01489 
<a name="l01490"></a>01490     <span class="comment">/* create an OpenGL context */</span>
<a name="l01491"></a>01491     allegro_glrc = wglCreateContext(__allegro_gl_hdc);
<a name="l01492"></a>01492     
<a name="l01493"></a>01493     <span class="keywordflow">if</span> (!allegro_glrc) { <span class="comment">/* make the context the current one */</span>
<a name="l01494"></a>01494         log_win32_error(<span class="stringliteral">&quot;win_init&quot;</span>,
<a name="l01495"></a>01495                     <span class="stringliteral">&quot;Unable to create a render context!&quot;</span>,
<a name="l01496"></a>01496                     GetLastError());
<a name="l01497"></a>01497         <span class="keywordflow">goto</span> Error;
<a name="l01498"></a>01498     }
<a name="l01499"></a>01499     <span class="keywordflow">if</span> (!wglMakeCurrent(__allegro_gl_hdc, allegro_glrc)) {
<a name="l01500"></a>01500         log_win32_error(<span class="stringliteral">&quot;win_init&quot;</span>,
<a name="l01501"></a>01501                     <span class="stringliteral">&quot;Unable to make the context current!&quot;</span>,
<a name="l01502"></a>01502                     GetLastError());
<a name="l01503"></a>01503         <span class="keywordflow">goto</span> Error;
<a name="l01504"></a>01504     }
<a name="l01505"></a>01505 
<a name="l01506"></a>01506 
<a name="l01507"></a>01507     <span class="keywordflow">if</span> (__wglGetPixelFormatAttribivARB || __wglGetPixelFormatAttribivEXT) {
<a name="l01508"></a>01508         describe_pixel_format_new(__allegro_gl_hdc, pf, desktop_depth,
<a name="l01509"></a>01509                                   NULL, NULL, &amp;allegro_gl_display_info);
<a name="l01510"></a>01510     }
<a name="l01511"></a>01511     <span class="keywordflow">else</span> {
<a name="l01512"></a>01512         describe_pixel_format_old(__allegro_gl_hdc, pf, desktop_depth,
<a name="l01513"></a>01513                                   NULL, NULL, &amp;allegro_gl_display_info);
<a name="l01514"></a>01514     }
<a name="l01515"></a>01515     
<a name="l01516"></a>01516     
<a name="l01517"></a>01517     __allegro_gl_set_allegro_image_format(FALSE);
<a name="l01518"></a>01518     set_color_depth(allegro_gl_display_info.colour_depth);
<a name="l01519"></a>01519     allegro_gl_display_info.w = w;
<a name="l01520"></a>01520     allegro_gl_display_info.h = h;
<a name="l01521"></a>01521 
<a name="l01522"></a>01522     
<a name="l01523"></a>01523     <span class="comment">/* &lt;rohannessian&gt; Win98/2k/XP&#39;s window forground rules don&#39;t let us</span>
<a name="l01524"></a>01524 <span class="comment">     * make our window the topmost window on launch. This causes issues on </span>
<a name="l01525"></a>01525 <span class="comment">     * full-screen apps, as DInput loses input focus on them.</span>
<a name="l01526"></a>01526 <span class="comment">     * We use this trick to force the window to be topmost, when switching</span>
<a name="l01527"></a>01527 <span class="comment">     * to full-screen only. Note that this only works for Win98 and greater.</span>
<a name="l01528"></a>01528 <span class="comment">     * Win95 will ignore our SystemParametersInfo() calls.</span>
<a name="l01529"></a>01529 <span class="comment">     * </span>
<a name="l01530"></a>01530 <span class="comment">     * See http://support.microsoft.com:80/support/kb/articles/Q97/9/25.asp</span>
<a name="l01531"></a>01531 <span class="comment">     * for details.</span>
<a name="l01532"></a>01532 <span class="comment">     */</span>
<a name="l01533"></a>01533     {
<a name="l01534"></a>01534         DWORD lock_time;
<a name="l01535"></a>01535 
<a name="l01536"></a>01536 <span class="preprocessor">#define SPI_GETFOREGROUNDLOCKTIMEOUT 0x2000</span>
<a name="l01537"></a>01537 <span class="preprocessor"></span><span class="preprocessor">#define SPI_SETFOREGROUNDLOCKTIMEOUT 0x2001</span>
<a name="l01538"></a>01538 <span class="preprocessor"></span>        <span class="keywordflow">if</span> (fullscreen) {
<a name="l01539"></a>01539             SystemParametersInfo(SPI_GETFOREGROUNDLOCKTIMEOUT,
<a name="l01540"></a>01540                                  0, (LPVOID)&amp;lock_time, 0);
<a name="l01541"></a>01541             SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT,
<a name="l01542"></a>01542                                  0, (LPVOID)0,
<a name="l01543"></a>01543                                  SPIF_SENDWININICHANGE | SPIF_UPDATEINIFILE);
<a name="l01544"></a>01544         }
<a name="l01545"></a>01545 
<a name="l01546"></a>01546         ShowWindow(wnd, SW_SHOWNORMAL);
<a name="l01547"></a>01547         SetForegroundWindow(wnd);
<a name="l01548"></a>01548         <span class="comment">/* In some rare cases, it doesn&#39;t seem to work without the loop. And we</span>
<a name="l01549"></a>01549 <span class="comment">         * absolutely need this to succeed, else we trap the user in a</span>
<a name="l01550"></a>01550 <span class="comment">         * fullscreen window without input.</span>
<a name="l01551"></a>01551 <span class="comment">         */</span>
<a name="l01552"></a>01552         <span class="keywordflow">while</span> (GetForegroundWindow() != wnd) {
<a name="l01553"></a>01553             rest(100);
<a name="l01554"></a>01554             SetForegroundWindow(wnd);
<a name="l01555"></a>01555         }
<a name="l01556"></a>01556         UpdateWindow(wnd);
<a name="l01557"></a>01557 
<a name="l01558"></a>01558         <span class="keywordflow">if</span> (fullscreen) {
<a name="l01559"></a>01559             SystemParametersInfo(SPI_SETFOREGROUNDLOCKTIMEOUT,
<a name="l01560"></a>01560                                  0, (LPVOID)lock_time,
<a name="l01561"></a>01561                                  SPIF_SENDWININICHANGE | SPIF_UPDATEINIFILE);
<a name="l01562"></a>01562         }
<a name="l01563"></a>01563 <span class="preprocessor">#undef SPI_GETFOREGROUNDLOCKTIMEOUT</span>
<a name="l01564"></a>01564 <span class="preprocessor"></span><span class="preprocessor">#undef SPI_SETFOREGROUNDLOCKTIMEOUT</span>
<a name="l01565"></a>01565 <span class="preprocessor"></span>    }
<a name="l01566"></a>01566         
<a name="l01567"></a>01567     win_grab_input();
<a name="l01568"></a>01568     
<a name="l01569"></a>01569     <span class="keywordflow">if</span> (fullscreen) {
<a name="l01570"></a>01570         <a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>= allegro_gl_create_screen(&amp;gfx_allegro_gl_fullscreen,
<a name="l01571"></a>01571                                         w, h, <a class="code" href="group__settings.html#ga2179291ddb3cb528c3c0cf84af5c51a9" title="Reads the setting of a configuration option.">allegro_gl_get</a>(<a class="code" href="group__settings.html#ga71846e567336fe02f8f063af1282ddc5" title="Specify the total color depth of the frame buffer.">AGL_COLOR_DEPTH</a>));
<a name="l01572"></a>01572     }
<a name="l01573"></a>01573     <span class="keywordflow">else</span> {
<a name="l01574"></a>01574         <a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>= allegro_gl_create_screen(&amp;gfx_allegro_gl_windowed,
<a name="l01575"></a>01575                                         w, h, <a class="code" href="group__settings.html#ga2179291ddb3cb528c3c0cf84af5c51a9" title="Reads the setting of a configuration option.">allegro_gl_get</a>(<a class="code" href="group__settings.html#ga71846e567336fe02f8f063af1282ddc5" title="Specify the total color depth of the frame buffer.">AGL_COLOR_DEPTH</a>));
<a name="l01576"></a>01576     }
<a name="l01577"></a>01577 
<a name="l01578"></a>01578     <span class="keywordflow">if</span> (!<a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>) {
<a name="l01579"></a>01579         ChangeDisplaySettings(NULL, 0);
<a name="l01580"></a>01580         <span class="keywordflow">goto</span> Error;
<a name="l01581"></a>01581     }
<a name="l01582"></a>01582     
<a name="l01583"></a>01583 
<a name="l01584"></a>01584     TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): GLScreen: %ix%ix%i\n&quot;</span>,
<a name="l01585"></a>01585           w, h, <a class="code" href="group__settings.html#ga2179291ddb3cb528c3c0cf84af5c51a9" title="Reads the setting of a configuration option.">allegro_gl_get</a>(<a class="code" href="group__settings.html#ga71846e567336fe02f8f063af1282ddc5" title="Specify the total color depth of the frame buffer.">AGL_COLOR_DEPTH</a>));
<a name="l01586"></a>01586 
<a name="l01587"></a>01587     <a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>-&gt;id |= BMP_ID_VIDEO | BMP_ID_MASK;
<a name="l01588"></a>01588 
<a name="l01589"></a>01589     __allegro_gl_valid_context = TRUE;
<a name="l01590"></a>01590     __allegro_gl_driver = &amp;allegro_gl_win;
<a name="l01591"></a>01591     initialized = 1;
<a name="l01592"></a>01592 
<a name="l01593"></a>01593     <span class="comment">/* Print out OpenGL version info */</span>
<a name="l01594"></a>01594     TRACE(PREFIX_I <span class="stringliteral">&quot;OpenGL Version: %s\n&quot;</span>, (AL_CONST <span class="keywordtype">char</span>*)glGetString(GL_VERSION));
<a name="l01595"></a>01595     TRACE(PREFIX_I <span class="stringliteral">&quot;Vendor: %s\n&quot;</span>, (AL_CONST <span class="keywordtype">char</span>*)glGetString(GL_VENDOR));
<a name="l01596"></a>01596     TRACE(PREFIX_I <span class="stringliteral">&quot;Renderer: %s\n\n&quot;</span>, (AL_CONST <span class="keywordtype">char</span>*)glGetString(GL_RENDERER));
<a name="l01597"></a>01597 
<a name="l01598"></a>01598     <span class="comment">/* Detect if the GL driver is based on Mesa */</span>
<a name="l01599"></a>01599     allegro_gl_info.is_mesa_driver = FALSE;
<a name="l01600"></a>01600     <span class="keywordflow">if</span> (strstr((AL_CONST <span class="keywordtype">char</span>*)glGetString(GL_VERSION),<span class="stringliteral">&quot;Mesa&quot;</span>)) {
<a name="l01601"></a>01601         AGL_LOG(1, <span class="stringliteral">&quot;OpenGL driver based on Mesa\n&quot;</span>);
<a name="l01602"></a>01602         allegro_gl_info.is_mesa_driver = TRUE;
<a name="l01603"></a>01603     }
<a name="l01604"></a>01604 
<a name="l01605"></a>01605     <span class="comment">/* init the GL extensions */</span>
<a name="l01606"></a>01606     __allegro_gl_manage_extensions();
<a name="l01607"></a>01607     
<a name="l01608"></a>01608     <span class="comment">/* Update screen vtable in order to use AGL&#39;s */</span>
<a name="l01609"></a>01609     __allegro_gl__glvtable_update_vtable(&amp;<a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>-&gt;vtable);
<a name="l01610"></a>01610     memcpy(&amp;_screen_vtable, <a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>-&gt;vtable, <span class="keyword">sizeof</span>(GFX_VTABLE));
<a name="l01611"></a>01611     <a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>-&gt;vtable = &amp;_screen_vtable;
<a name="l01612"></a>01612 
<a name="l01613"></a>01613     <span class="comment">/* Print out WGL extension info */</span>
<a name="l01614"></a>01614     <span class="keywordflow">if</span> (wglGetExtensionsStringARB) {
<a name="l01615"></a>01615         AGL_LOG(1, <span class="stringliteral">&quot;WGL Extensions :\n&quot;</span>);
<a name="l01616"></a>01616 <span class="preprocessor">#if LOGLEVEL &gt;= 1</span>
<a name="l01617"></a>01617 <span class="preprocessor"></span>        __allegro_gl_print_extensions((AL_CONST <span class="keywordtype">char</span>*)wglGetExtensionsStringARB(wglGetCurrentDC()));
<a name="l01618"></a>01618 <span class="preprocessor">#endif</span>
<a name="l01619"></a>01619 <span class="preprocessor"></span>    }
<a name="l01620"></a>01620     <span class="keywordflow">else</span> {
<a name="l01621"></a>01621         TRACE(PREFIX_I <span class="stringliteral">&quot;win_init(): No WGL Extensions available\n&quot;</span>);
<a name="l01622"></a>01622     }
<a name="l01623"></a>01623 
<a name="l01624"></a>01624     gfx_capabilities |= GFX_HW_CURSOR;
<a name="l01625"></a>01625 
<a name="l01626"></a>01626     <span class="comment">/* Initialize a reasonable viewport. Those should be OpenGL defaults,</span>
<a name="l01627"></a>01627 <span class="comment">     * but some drivers don&#39;t implement this correctly.</span>
<a name="l01628"></a>01628 <span class="comment">     */</span> 
<a name="l01629"></a>01629     glViewport(0, 0, SCREEN_W, SCREEN_H);
<a name="l01630"></a>01630     glMatrixMode(GL_PROJECTION);
<a name="l01631"></a>01631     glLoadIdentity();
<a name="l01632"></a>01632     glMatrixMode(GL_MODELVIEW);
<a name="l01633"></a>01633     glLoadIdentity();
<a name="l01634"></a>01634 
<a name="l01635"></a>01635     <span class="keywordflow">if</span> (<a class="code" href="group__extensions.html#ga7492f6f6acc608789210560ee63e5436" title="List of OpenGL extensions supported by AllegroGL.">allegro_gl_extensions_GL</a>.ARB_multisample) {
<a name="l01636"></a>01636         <span class="comment">/* Workaround some &quot;special&quot; drivers that do not export the extension</span>
<a name="l01637"></a>01637 <span class="comment">         * once it was promoted to core.*/</span>
<a name="l01638"></a>01638         <span class="keywordflow">if</span> (<a class="code" href="group__core.html#ga444d507eaeb5ba800787f6a81827615d" title="Returns the OpenGL version number of the client (the computer the program is running on)...">allegro_gl_opengl_version</a>() &gt;= 1.3)
<a name="l01639"></a>01639             glSampleCoverage(1.0, GL_FALSE);
<a name="l01640"></a>01640         <span class="keywordflow">else</span>
<a name="l01641"></a>01641             glSampleCoverageARB(1.0, GL_FALSE);
<a name="l01642"></a>01642     }
<a name="l01643"></a>01643     
<a name="l01644"></a>01644     <span class="comment">/* Set up some variables that some GL drivers omit */</span>
<a name="l01645"></a>01645     glBindTexture(GL_TEXTURE_2D, 0);
<a name="l01646"></a>01646     
<a name="l01647"></a>01647     screen = <a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>;
<a name="l01648"></a>01648 
<a name="l01649"></a>01649     <span class="keywordflow">if</span> (fullscreen)
<a name="l01650"></a>01650         remove_dummy_window();
<a name="l01651"></a>01651 
<a name="l01652"></a>01652     <span class="keywordflow">return</span> <a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a>;
<a name="l01653"></a>01653     
<a name="l01654"></a>01654 Error:
<a name="l01655"></a>01655     <span class="keywordflow">if</span> (allegro_glrc) {
<a name="l01656"></a>01656         wglDeleteContext(allegro_glrc);
<a name="l01657"></a>01657     }
<a name="l01658"></a>01658     <span class="keywordflow">if</span> (__allegro_gl_hdc) {
<a name="l01659"></a>01659         ReleaseDC(wnd, __allegro_gl_hdc);
<a name="l01660"></a>01660     }
<a name="l01661"></a>01661     __allegro_gl_hdc = NULL;
<a name="l01662"></a>01662     ChangeDisplaySettings(NULL, 0);
<a name="l01663"></a>01663     allegro_gl_win_exit(NULL);
<a name="l01664"></a>01664 
<a name="l01665"></a>01665     <span class="keywordflow">return</span> NULL;
<a name="l01666"></a>01666 }
<a name="l01667"></a>01667 
<a name="l01668"></a>01668 
<a name="l01669"></a>01669 
<a name="l01670"></a>01670 <span class="keyword">static</span> BITMAP *allegro_gl_win_init_windowed(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> v_w, <span class="keywordtype">int</span> v_h,
<a name="l01671"></a>01671                                             <span class="keywordtype">int</span> color_depth)
<a name="l01672"></a>01672 {
<a name="l01673"></a>01673     fullscreen = 0;
<a name="l01674"></a>01674     <span class="keywordflow">return</span> allegro_gl_win_init(w, h, v_w, v_h);
<a name="l01675"></a>01675 }
<a name="l01676"></a>01676 
<a name="l01677"></a>01677 
<a name="l01678"></a>01678 
<a name="l01679"></a>01679 <span class="keyword">static</span> BITMAP *allegro_gl_win_init_fullscreen(<span class="keywordtype">int</span> w, <span class="keywordtype">int</span> h, <span class="keywordtype">int</span> v_w, <span class="keywordtype">int</span> v_h,
<a name="l01680"></a>01680                                               <span class="keywordtype">int</span> color_depth)
<a name="l01681"></a>01681 {
<a name="l01682"></a>01682     fullscreen = 1;
<a name="l01683"></a>01683     <span class="keywordflow">return</span> allegro_gl_win_init(w, h, v_w, v_h);
<a name="l01684"></a>01684 }
<a name="l01685"></a>01685 
<a name="l01686"></a>01686 
<a name="l01687"></a>01687 
<a name="l01688"></a>01688 <span class="keyword">static</span> <span class="keywordtype">void</span> allegro_gl_win_exit(<span class="keyword">struct</span> BITMAP *b)
<a name="l01689"></a>01689 {
<a name="l01690"></a>01690     <span class="comment">/* XXX &lt;rohannessian&gt; For some reason, uncommenting this line will blank</span>
<a name="l01691"></a>01691 <span class="comment">     * out the log file.</span>
<a name="l01692"></a>01692 <span class="comment">     */</span>
<a name="l01693"></a>01693     <span class="comment">//TRACE(PREFIX_I &quot;allegro_gl_win_exit: Shutting down.\n&quot;);</span>
<a name="l01694"></a>01694     __allegro_gl_unmanage_extensions();
<a name="l01695"></a>01695     
<a name="l01696"></a>01696     <span class="keywordflow">if</span> (allegro_glrc) {
<a name="l01697"></a>01697         wglDeleteContext(allegro_glrc);
<a name="l01698"></a>01698         allegro_glrc = NULL;
<a name="l01699"></a>01699     }
<a name="l01700"></a>01700         
<a name="l01701"></a>01701     <span class="keywordflow">if</span> (__allegro_gl_hdc) {
<a name="l01702"></a>01702         ReleaseDC(wnd, __allegro_gl_hdc);
<a name="l01703"></a>01703         __allegro_gl_hdc = NULL;
<a name="l01704"></a>01704     }
<a name="l01705"></a>01705 
<a name="l01706"></a>01706     <span class="keywordflow">if</span> (fullscreen &amp;&amp; initialized) {
<a name="l01707"></a>01707         <span class="comment">/* Restore screen */</span>
<a name="l01708"></a>01708         ChangeDisplaySettings(NULL, 0);
<a name="l01709"></a>01709         _set_current_refresh_rate(0);
<a name="l01710"></a>01710     }
<a name="l01711"></a>01711     initialized = 0;
<a name="l01712"></a>01712 
<a name="l01713"></a>01713     <span class="comment">/* Note: Allegro will destroy screen (== allegro_gl_screen),</span>
<a name="l01714"></a>01714 <span class="comment">     * so don&#39;t destroy it here.</span>
<a name="l01715"></a>01715 <span class="comment">     */</span>
<a name="l01716"></a>01716     <span class="comment">//destroy_bitmap(allegro_gl_screen);</span>
<a name="l01717"></a>01717     <a class="code" href="alleggl_8c.html#a84d9cceae55bf273f9aab7512b353284" title="Direct-mode GL `screen&amp;#39; bitmap.">allegro_gl_screen</a> = NULL;
<a name="l01718"></a>01718     
<a name="l01719"></a>01719     <span class="comment">/* hide the window */</span>
<a name="l01720"></a>01720     system_driver-&gt;restore_console_state();
<a name="l01721"></a>01721 
<a name="l01722"></a>01722     <span class="comment">/* restore original Allegro styles */</span>
<a name="l01723"></a>01723     SetWindowLong(wnd, GWL_STYLE, style_saved);
<a name="l01724"></a>01724     SetWindowLong(wnd, GWL_EXSTYLE, exstyle_saved);
<a name="l01725"></a>01725     SetWindowPos(wnd, 0, 0, 0, 0, 0, SWP_NOMOVE | SWP_NOSIZE | SWP_NOZORDER
<a name="l01726"></a>01726                                    | SWP_FRAMECHANGED);
<a name="l01727"></a>01727 
<a name="l01728"></a>01728     __allegro_gl_valid_context = FALSE;
<a name="l01729"></a>01729     
<a name="l01730"></a>01730     <span class="keywordflow">return</span>;
<a name="l01731"></a>01731 }
<a name="l01732"></a>01732 
<a name="l01733"></a>01733 
<a name="l01734"></a>01734 <span class="comment">/* </span>
<a name="l01735"></a>01735 <span class="comment">   Returns TRUE is dm doesn&#39;t match any mode in mode_list, FALSE otherwise.</span>
<a name="l01736"></a>01736 <span class="comment">*/</span>
<a name="l01737"></a>01737 <span class="keyword">static</span> <span class="keywordtype">int</span> is_mode_entry_unique(GFX_MODE_LIST *mode_list, DEVMODE *dm) {
<a name="l01738"></a>01738     <span class="keywordtype">int</span> i;
<a name="l01739"></a>01739     
<a name="l01740"></a>01740     <span class="keywordflow">for</span> (i = 0; i &lt; mode_list-&gt;num_modes; ++i) {
<a name="l01741"></a>01741         <span class="keywordflow">if</span> (mode_list-&gt;mode[i].width == (<span class="keywordtype">int</span>)dm-&gt;dmPelsWidth
<a name="l01742"></a>01742             &amp;&amp; mode_list-&gt;mode[i].height == (<span class="keywordtype">int</span>)dm-&gt;dmPelsHeight
<a name="l01743"></a>01743             &amp;&amp; mode_list-&gt;mode[i].bpp == (<span class="keywordtype">int</span>)dm-&gt;dmBitsPerPel)
<a name="l01744"></a>01744             <span class="keywordflow">return</span> FALSE;
<a name="l01745"></a>01745     }
<a name="l01746"></a>01746     
<a name="l01747"></a>01747     <span class="keywordflow">return</span> TRUE;
<a name="l01748"></a>01748 }
<a name="l01749"></a>01749 
<a name="l01750"></a>01750 
<a name="l01751"></a>01751 
<a name="l01752"></a>01752 <span class="comment">/* Returns a list of valid video modes */</span>
<a name="l01753"></a>01753 <span class="keyword">static</span> GFX_MODE_LIST* allegro_gl_win_fetch_mode_list(<span class="keywordtype">void</span>)
<a name="l01754"></a>01754 {
<a name="l01755"></a>01755     <span class="keywordtype">int</span> c, modes_count;
<a name="l01756"></a>01756     GFX_MODE_LIST *mode_list;
<a name="l01757"></a>01757     DEVMODE dm;
<a name="l01758"></a>01758 
<a name="l01759"></a>01759     dm.dmSize = <span class="keyword">sizeof</span>(DEVMODE);
<a name="l01760"></a>01760 
<a name="l01761"></a>01761     <span class="comment">/* Allocate space for mode list. */</span>
<a name="l01762"></a>01762     mode_list = malloc(<span class="keyword">sizeof</span>(GFX_MODE_LIST));
<a name="l01763"></a>01763     <span class="keywordflow">if</span> (!mode_list) {
<a name="l01764"></a>01764         <span class="keywordflow">return</span> NULL;
<a name="l01765"></a>01765     }
<a name="l01766"></a>01766 
<a name="l01767"></a>01767     <span class="comment">/* Allocate and fill the first mode in case EnumDisplaySettings fails at</span>
<a name="l01768"></a>01768 <span class="comment">     * first call.</span>
<a name="l01769"></a>01769 <span class="comment">     */</span>
<a name="l01770"></a>01770     mode_list-&gt;mode = malloc(<span class="keyword">sizeof</span>(GFX_MODE));
<a name="l01771"></a>01771     <span class="keywordflow">if</span> (!mode_list-&gt;mode) {
<a name="l01772"></a>01772         free(mode_list);
<a name="l01773"></a>01773         <span class="keywordflow">return</span> NULL;
<a name="l01774"></a>01774     }
<a name="l01775"></a>01775     mode_list-&gt;mode[0].width = 0;
<a name="l01776"></a>01776     mode_list-&gt;mode[0].height = 0;
<a name="l01777"></a>01777     mode_list-&gt;mode[0].bpp = 0;
<a name="l01778"></a>01778     mode_list-&gt;num_modes = 0;
<a name="l01779"></a>01779 
<a name="l01780"></a>01780     modes_count = 0;
<a name="l01781"></a>01781     c = 0;
<a name="l01782"></a>01782     <span class="keywordflow">while</span> (EnumDisplaySettings(NULL, c, &amp;dm)) {
<a name="l01783"></a>01783         mode_list-&gt;mode = realloc(mode_list-&gt;mode,
<a name="l01784"></a>01784                                 <span class="keyword">sizeof</span>(GFX_MODE) * (modes_count + 2));
<a name="l01785"></a>01785         <span class="keywordflow">if</span> (!mode_list-&gt;mode) {
<a name="l01786"></a>01786             free(mode_list);
<a name="l01787"></a>01787             <span class="keywordflow">return</span> NULL;
<a name="l01788"></a>01788         }
<a name="l01789"></a>01789 
<a name="l01790"></a>01790         <span class="comment">/* Filter modes with bpp lower than 9, and those which are already</span>
<a name="l01791"></a>01791 <span class="comment">         * in there.</span>
<a name="l01792"></a>01792 <span class="comment">         */</span>
<a name="l01793"></a>01793         <span class="keywordflow">if</span> (dm.dmBitsPerPel &gt; 8 &amp;&amp; is_mode_entry_unique(mode_list, &amp;dm)) {
<a name="l01794"></a>01794             mode_list-&gt;mode[modes_count].width = dm.dmPelsWidth;
<a name="l01795"></a>01795             mode_list-&gt;mode[modes_count].height = dm.dmPelsHeight;
<a name="l01796"></a>01796             mode_list-&gt;mode[modes_count].bpp = dm.dmBitsPerPel;
<a name="l01797"></a>01797             ++modes_count;
<a name="l01798"></a>01798             mode_list-&gt;mode[modes_count].width = 0;
<a name="l01799"></a>01799             mode_list-&gt;mode[modes_count].height = 0;
<a name="l01800"></a>01800             mode_list-&gt;mode[modes_count].bpp = 0;
<a name="l01801"></a>01801             mode_list-&gt;num_modes = modes_count;
<a name="l01802"></a>01802         }
<a name="l01803"></a>01803         ++c;
<a name="l01804"></a>01804     };
<a name="l01805"></a>01805 
<a name="l01806"></a>01806     <span class="keywordflow">return</span> mode_list;
<a name="l01807"></a>01807 }
<a name="l01808"></a>01808 
<a name="l01809"></a>01809 
<a name="l01810"></a>01810 
<a name="l01811"></a>01811 
<a name="l01812"></a>01812 <span class="comment">/* AllegroGL driver routines */</span>
<a name="l01813"></a>01813 
<a name="l01814"></a>01814 <span class="keyword">static</span> <span class="keywordtype">void</span> flip(<span class="keywordtype">void</span>)
<a name="l01815"></a>01815 {
<a name="l01816"></a>01816     SwapBuffers(__allegro_gl_hdc);
<a name="l01817"></a>01817 }
<a name="l01818"></a>01818 
<a name="l01819"></a>01819 
<a name="l01820"></a>01820 
<a name="l01821"></a>01821 <span class="keyword">static</span> <span class="keywordtype">void</span> gl_on(<span class="keywordtype">void</span>)
<a name="l01822"></a>01822 {
<a name="l01823"></a>01823     <span class="keywordflow">return</span>;
<a name="l01824"></a>01824 }
<a name="l01825"></a>01825 
<a name="l01826"></a>01826 
<a name="l01827"></a>01827 
<a name="l01828"></a>01828 <span class="keyword">static</span> <span class="keywordtype">void</span> gl_off(<span class="keywordtype">void</span>)
<a name="l01829"></a>01829 {
<a name="l01830"></a>01830     <span class="keywordflow">return</span>;
<a name="l01831"></a>01831 }
<a name="l01832"></a>01832 
<a name="l01833"></a>01833 
<a name="l01834"></a>01834 
<a name="l01835"></a>01835 <span class="comment">/* AllegroGL driver */</span>
<a name="l01836"></a>01836 
<a name="l01837"></a>01837 <span class="keyword">static</span> <span class="keyword">struct </span>allegro_gl_driver allegro_gl_win = {
<a name="l01838"></a>01838     flip, gl_on, gl_off, NULL
<a name="l01839"></a>01839 };
<a name="l01840"></a>01840 
</pre></div></div>
</div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><b>win.c</b>      </li>
      <li class="footer">Generated on Thu May 19 2011 23:20:20 for AllegroGL by&#160;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.3 </li>
    </ul>
  </div>

</body>
</html>
